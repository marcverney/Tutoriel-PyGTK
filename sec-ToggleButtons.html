<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
<title>6.2. Les boutons à bascule</title>
<link rel="stylesheet" href="pygtktutfr.css">
<meta name="keywords" content="python,pygtk,tutoriel,traduction,bouton">
<link rel="start" href="index.html" title="Tutoriel PyGTK 2.0">
<link rel="home" href="index.html" title="Table des matières">
<link rel="up" href="ch-ButtonWidget.html" title="Chapitre 6. Les boutons">
<link rel="previous" href="ch-ButtonWidget.html" title="Chapitre 6. Les boutons">
<link rel="next" href="sec-CheckButtons.html" title="6.3. Les cases à cocher">
</head>

<body>
<div class="navheader">

<table width="100%" summary="En-tête de navigation">
<tr>
<th colspan="3" align="center">6.2. Les boutons à bascule</th></tr>
<tr>
<td width="20%" align="left"><a accesskey="p" href="ch-ButtonWidget.html">Préc.</a> </td>
<th width="60%" align="center">Chapitre 6. Les boutons</th>
<td width="20%" align="right"> <a accesskey="n" href="sec-CheckButtons.html">Suiv.</a></td>
</tr></table>

<hr>
</div>

<div class="sect1">
<div class="titlepage">
<div><h2 class="title" style="clear: both"><a name="BoutonsBascule"></a>6.2. Les boutons à bascule</h2></div></div>

<p>Le bouton à bascule dérive du bouton simple et lui est donc très
similaire. Il a cependant ceci de différent qu'il possède deux états
et qu'un clic le fait basculer de l'un à l'autre. Lorsqu'il est enfoncé,
un clic le fait remonter. Un autre clic et le voilà de nouveau enfoncé.</p>
<p>Les boutons à bascule sont la base des cases à cocher et des boutons radio,
ces derniers héritent donc de beaucoup de leurs appels (nous le signalerons le
cas échéant).</p>
<p>Création d'un bouton à bascule&nbsp;:</p>

<pre class="programlisting">
  bouton_bascule = gtk.ToggleButton(<b><tt>label</tt></b>=None)
</pre>

<p>Comme vous pouvez l'imaginer, le fonctionnement de cet appel est identique à
celui des boutons normaux. Si aucune étiquette n'est spécifiée,
le bouton sera vierge. Dans le cas contraire, le texte donné sera inspecté
à la recherche de caractères mnémoniques (préfixés
par '<tt>_</tt>').</p>
<p>Pour récupérer l'état d'un bouton à bascule, ainsi que
des boutons radio et des cases à cocher, on fait appel à une construction
semblable à l'exemple ci-dessous. Elle teste l'état du bouton en invoquant
la méthode <tt>get_active</tt>() de <tt>gtk.ToggleButton</tt>. Parmi les signaux
émis par les boutons à bascule, celui qui nous intéresse est
"<tt>toggled</tt>". Pour vérifier l'état d'un bouton à
bascule, on définira alors un gestionnaire de signal qui se chargera de le capter,
puis qui accèdera aux attributs de l'objet afin de déterminer son état.
La fonction de rappel ressemblera à ceci&nbsp;:</p>

<pre class="programlisting">
  def fct_rappel_bascule(widget, donnees):
      if widget.get_active():
          # si le contrôle arrive ici, le bouton à bascule est enfoncé
      else:
          # si le contrôle arrive ici, le bouton à bascule est relevé
</pre>

<p>Pour forcer l'état d'un bouton à bascule (et de ses descendants les cases
à cocher et les boutons radio) on utilise la méthode&nbsp;:</p>

<pre class="programlisting">
  bouton_bascule.set_active(<B><tt>is_active</tt></B>)
</pre>

<p>La méthode ci-dessus peut être utilisée pour imposer l'état
d'un bouton à bascule, et de ses descendants les cases à cocher et les boutons
radio. En donnant les valeurs TRUE ou FALSE à l'argument <i><tt>is_active</tt></i>,
on indique que le bouton doit être respectivement enfoncé ou relevé.
Lors de sa création, un bouton à bascule est en position relevée
(FALSE) par défaut.</p>
<p>Notez que lorsqu'on utilise la méthode <tt>set_active</tt>() et que l'état
est effectivement modifié, les signaux "<tt>clicked</tt>" et
"<tt>toggled</tt>" sont automatiquement émis par le bouton.</p>

<pre class="programlisting">
  bouton_bascule.get_active()
</pre>

<p>Cette méthode renvoie l'état actuel du bouton à bascule sous la
forme d'une valeur booléenne TRUE/FALSE.</p>
<p>Le programme <a href="exemples/boutonsbascule.py" target="_top"><B>boutonsbascule.py</B></a>
donne un exemple courant d'utilisation des boutons à bascule.
La <a title="Figure 6.2. Exemple de boutons à bascule"
href="sec-ToggleButtons.html#basculefig">figure 6.2</a> montre la fenêtre
obtenue, dans laquelle le deuxième bouton est enfoncé&nbsp;:</p>

<div class="figure"><a name="basculefig"></a><p class="title">
<b>Figure 6.2. Exemple de boutons à bascule</b></p>
<div class="mediaobject" align="center"><img src="figures/boutonsbascule.png" align="center">
</div></div>

<p>Voici le code source du programme&nbsp;:</p>

<pre class=programlisting>
     1   #!/usr/bin/env python
     2
     3   # exemple boutonsbascule.py
     4
     5   import pygtk
     6   pygtk.require('2.0')
     7   import gtk
     8
     9   class BoutonsBascule:
    10       # Notre fonction de rappel. Le parametre "donnees"
    11       # transmis a cette methode est affiche sur stdout
    12       def fct_rappel(self, widget, donnees=None):
    13           print "Le %s a ete %s." % (donnees, ("releve", "enfonce")[widget.get_active()])
    14
    15       # Cette fonction de rappel quitte le programme
    16       def evnmt_delete(self, widget, evenement, donnees=None):
    17           gtk.main_quit()
    18           return gtk.FALSE
    19
    20       def __init__(self):
    21           # Creation d'une nouvelle fenetre.
    22           self.fenetre = gtk.Window(gtk.WINDOW_TOPLEVEL)
    23
    24           # On definit le titre de la fenetre.
    25           self.fenetre.set_title("Boutons a bascule")
    26
    27           # On definit un gestionnaire de signal pour "delete_event",
    28           # qui quitte GTK immediatement.
    29           self.fenetre.connect("delete_event", self.evnmt_delete)
    30
    31           # On fixe la largeur des bordures de la fenetre.
    32           self.fenetre.set_border_width(20)
    33
    34           # Creation d'une boite verticale.
    35           boite_v = gtk.VBox(True, 2)
    36
    37           # On place la VBox dans la fenetre principale.
    38           self.fenetre.add(boite_v)
    39
    40           # Creation du premier bouton.
    41           bouton = gtk.ToggleButton("bouton a bascule 1")
    42
    43           # Lorsque l'on change l'etat du bouton, la methode fct_rappel() est
    44           # appelee, avec un pointeur sur "bouton a bascule 1" comme argument.
    45           bouton.connect("toggled", self.fct_rappel, "bouton a bascule 1")
    46
    47
    48           # Insertion du bouton 1 dans le quart superieur gauche du tableau.
    49           boite_v.pack_start(bouton, True, True, 2)
    50
    51           bouton.show()
    52
    53           # Creation du deuxieme bouton.
    54
    55           bouton = gtk.ToggleButton("bouton a bascule 2")
    56
    57           # Lorsque l'on change l'etat du bouton, la methode fct_rappel() est
    58           # appelee, avec un pointeur sur "bouton a bascule 2" comme argument.
    59           bouton.connect("toggled", self.fct_rappel, "bouton a bascule 2")
    60           # Insertion du bouton 2 dans le quart superieur droit du tableau.
    61           boite_v.pack_start(bouton, True, True, 2)
    62
    63           bouton.show()
    64
    65           # Creation du bouton "Quitter".
    66           bouton = gtk.Button("Quitter")
    67
    68           # Lorsque l'on clique sur le bouton, la fonction mainquit() est
    69           # appelee et le programme se termine.
    70           bouton.connect("clicked", lambda wid: gtk.main_quit())
    71
    72           # Insertion du bouton "Quitter" dans les deux quarts inferieurs du tableau.
    73           boite_v.pack_start(bouton, True, True, 2)
    74
    75           bouton.show()
    76           boite_v.show()
    77           self.fenetre.show()
    78
    79   def main():
    80       gtk.main()
    81       return 0
    82
    83   if __name__ == "__main__":
    84       BoutonsBascule()
    85       main()
</pre>

<p>Les parties intéressantes sont les lignes 12-13, qui définissent la
méthode <tt>fct_rappel</tt>() chargée d'afficher le nom et l'état
du bouton à bascule quand celui-ci voit son état modifié, et les
lignes 45 et 59, qui connectent le signal "<tt>toggled</tt>" des deux boutons
à cette même méthode.</p></div>

<div class="navfooter">
<hr>

<table width="100%" summary="Bas de page de navigation">
<tr>
<td width="40%" align="left"><a accesskey="p" href="ch-ButtonWidget.html">Préc.</a> </td>
<td width="20%" align="center"><a accesskey="u" href="ch-ButtonWidget.html">Chapitre parent</a></td>
<td width="40%" align="right"> <a accesskey="n" href="sec-CheckButtons.html">Suiv.</a></td></tr>
<tr>
<td width="40%" align="left" valign="top">Chapitre 6. Les boutons</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Table des matières</a></td>
<td width="40%" align="right" valign="top">6.3. Les cases à cocher</td>
</tr></table>

</div>

</body>

</html>
