<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
<title>13.3. TextBuffer&nbsp;: le buffer de texte</title>
<link rel="stylesheet" href="pygtktutfr.css">
<meta name="keywords" content="python,pygtk,tutoriel,traduction,textview">
<link rel="start" href="index.html" title="Tutoriel PyGTK 2.0">
<link rel="home" href="index.html" title="Table des matières">
<link rel="up" href="ch-TextViewWidget.html" title="Chapitre 13. Le widget TextView">
<link rel="previous" href="sec-TextViews.html" title="13.2. TextView&nbsp;: la zone de texte">
<link rel="next" href="sec-TextIters.html" title="13.4. TextIter&nbsp;: les itérateurs de texte">
</head>

<body>
<div class="navheader">
<table width="100%" summary="En-tête de navigation">
<tr>
<th colspan="3" align="center">13.3. TextBuffer&nbsp;: le buffer de texte</th></tr>
<tr>
<td width="20%" align="left"><a accesskey="p" href="sec-TextViews.html">Préc.</a></td>
<th width="60%" align="center">Chapitre 13. Le widget TextView</th>
<td width="20%" align="right"><a accesskey="n" href="sec-TextIters.html">Suiv.</a></td>
</tr></table>

<hr>
</div>
<div class="sect1" lang="fr">
<div class="titlepage">
<div>
<h2 class="title" style="clear: both"><a name=TextBuffer></a>13.3. TextBuffer&nbsp;: le buffer de texte</h2></div></div>

<p>Le <tt>TextBuffer</tt> est le composant principal du système d'édition de texte de PyGTK. Il contient le texte, les <a title="13.6.1. Les TextTag" href="sec-TextTagsAndTextTagTables.html#TextTag"><tt>TextTag</tt></a> (dans une <a title="13.6.2. La TextTagTable" href="sec-TextTagsAndTextTagTables.html#TextTagTable"><tt>TextTagTable</tt></a>), et les <a title="13.5. TextMark&nbsp;: les marques de texte" href="sec-TextMarks.html"><tt>TextMark</tt></a>, qui, ensemble, décrivent comment le texte doit être affiché et permettent à l'utilisateur de modifier interactivement le texte ou la manière dont il s'affiche. Comme nous l'avons fait remarquer dans la section précédente, un <tt>TextBuffer</tt> est associé à un ou plusieurs <a title="13.2. TextView&nbsp;: la zone de texte" href="sec-TextViews.html"><tt>TextView</tt></a>, qui se chargent d'afficher son contenu.</p>
<p>La création d'un <tt>TextBuffer</tt> se fait soit automatiquement lorsque l'on crée un <a title="13.2. TextView&nbsp;: la zone de texte" href="sec-TextViews.html"><tt>TextView</tt></a>, soit avec la fonction&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte = TextBuffer(<b><tt>table</tt></b>=None)
</pre>

<p>où <i><tt>table</tt></i> est une <a title="13.6.2. La TextTagTable" href="sec-TextTagsAndTextTagTables.html#TextTagTable"><tt>TextTagTable</tt></a>. Si <i><tt>table</tt></i> n'est pas spécifié (ou s'il vaut None), une nouvelle <a title="13.6.2. La TextTagTable" href="sec-TextTagsAndTextTagTables.html#TextTagTable"><tt>TextTagTable</tt></a> sera créée pour le TextBuffer.</p>
<p>Un grand nombre de méthodes est disponible pour&nbsp;:</p>

<div class=itemizedlist><ul type=disc>
  <li>insérer et supprimer du texte dans un buffer
  <li>créer, supprimer et manipuler des marques
  <li>manipuler le curseur et la sélection
  <li>créer, appliquer, et supprimer des balises
  <li>spécifier et manipuler des <a title="13.4. TextIter&nbsp;: les itérateurs de texte" href="sec-TextIters.html"><tt>TextIter</tt></a>
  <li>récupérer des informations sur l'état du buffer</li></ul></div>

<div class="sect2" lang="fr"><div class="titlepage">
<div><h3 class="title"><a name="RecupInfoBuffer"></a>13.3.1. Récupérer des informations sur le buffer</h3></div></div>

<p>Vous pouvez récupérer le nombre de lignes d'un <tt>TextBuffer</tt> avec la méthode&nbsp;:</p>

<pre class=programlisting>
  nombre_lignes = bufferdetexte.get_line_count()
</pre>

<p>De la même manière, vous pouvez obtenir le nombre de caractères présents dans le <tt>TextBuffer</tt>&nbsp;:</p>

<pre class=programlisting>
  nombre_caract = bufferdetexte.get_char_count()
</pre>

<p>Lorsque le contenu du <tt>TextBuffer</tt> est modifié, le drapeau de modification est levé. L'état de ce drapeau peut être obtenu à l'aide de la méthode&nbsp;:</p>

<pre class=programlisting>
  modif = bufferdetexte.get_modified()
</pre>

<p>Si le programme sauvegarde le contenu du buffer, la méthode suivante peut réinitialiser le drapeau de modification&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.set_modified(<b><tt>choix</tt></b>)
</pre>

</div><div class="sect2" lang="fr"><div class="titlepage">
<div><h3 class="title"><a name="CreerTextIter"></a>13.3.2. Créer  des TextIter</h3></div></div>

<p>On utilise les <a title="13.4. TextIter&nbsp;: les itérateurs de texte" href="sec-TextIters.html"><tt>TextIter</tt></a> pour spécifier une position entre deux caractères d'un <tt>TextBuffer</tt>. Les méthodes du <tt>TextBuffer</tt> qui manipulent du texte s'en servent pour indiquer à quelle position elles doivent s'appliquer. Les <a title="13.4. TextIter&nbsp;: les itérateurs de texte" href="sec-TextIters.html"><tt>TextIter</tt></a> possèdent de nombreuses méthodes qui seront décrites dans la section <a title="13.4. TextIter&nbsp;: les itérateurs de texte" href="sec-TextIters.html"><tt>TextIter</tt></a>.</p>
<p>Les méthodes de <tt>TextBuffer</tt> basiques pour créer des <a title="13.4. TextIter&nbsp;: les itérateurs de texte" href="sec-TextIters.html"><tt>TextIter</tt></a> sont&nbsp;:</p>

<pre class=programlisting>
  iter = bufferdetexte.get_iter_at_offset(<b><tt>n</tt></b>)

  iter = bufferdetexte.get_iter_at_line(<b><tt>x</tt></b>)

  iter = bufferdetexte.get_iter_at_line_offset(<b><tt>x</tt></b>, <b><tt>n</tt></b>)

  iter = bufferdetexte.get_iter_at_mark(<b><tt>marque</tt></b>)
</pre>

<p><tt>get_iter_at_offset</tt>() crée un itérateur juste après le <i><tt>n</tt></i><sup><sup><font SIZE=1>ème</font></sup></sup> caractère à partir du début du <tt>TextBuffer</tt>.</p>
<p><tt>get_iter_at_line</tt>() crée un itérateur juste avant le premier caractère de la <i><tt>x</tt></i><sup><sup><font SIZE=1>ème</font></sup></sup> ligne.</p>
<p><tt>get_iter_at_line_offset</tt>() crée un itérateur juste après le <i><tt>n</tt></i><sup><sup><font SIZE=1>ème</font></sup></sup> caractère de la <i><tt>x</tt></i><sup><sup><font SIZE=1>ème</font></sup></sup> ligne.</p>
<p><tt>get_iter_at_mark</tt>() crée un itérateur à la même position que la <a title="13.5. TextMark&nbsp;: les marques de texte" href="sec-TextMarks.html"><tt>TextMark</tt></a> <i><tt>marque</tt></i>.</p>
<p>Le méthode qui suit crée un ou plusieurs <a title="13.4. TextIter&nbsp;: les itérateurs de texte" href="sec-TextIters.html"><tt>TextIter</tt></a> à des emplacements spécifiques du buffer&nbsp;:</p>

<pre class=programlisting>
  iterdebut = bufferdetexte.get_start_iter()

  iterfin = bufferdetexte.get_end_iter()

  iterdebut, iterfin = bufferdetexte.get_bounds()

  debut, fin = bufferdetexte.get_selection_bounds()
</pre>

<p><tt>get_start_iter</tt>() crée un itérateur juste avant le premier caractère du buffer.</p>
<p><tt>get_end_iter</tt>() crée un itérateur juste après le dernier caractère du buffer.</p>
<p><tt>get_bounds</tt>() crée un tuple de deux itérateurs respectivement situés juste avant le premier caractère et juste après le dernier caractère du buffer.</p>
<p><tt>get_selection_bounds</tt>() crée un tuple de deux itérateurs aux mêmes positions que les marques <i><tt>insert</tt></i> et <i><tt>selection_bound</tt></i> du buffer.</p></div>

<div class="sect2" lang="fr"><div class="titlepage">
<div><h3 class="title"><a name="InserRecupSuppr"></a>13.3.3. Insérer, récupérer et supprimer du texte</h3></div></div>

<p>Le texte contenu par un <tt>TextBuffer</tt> peut être défini avec la méthode suivante&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.set_text(<b><tt>texte</tt></b>)
</pre>

<p>Cette méthode remplace le contenu actuel de <i>bufferdetexte</i> par <i><tt>texte</tt></i>.</p>
<p>La méthode la plus générale pour insérer des caractères dans un <tt>TextBuffer</tt> est&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.insert(<b><tt>iter</tt></b>, <b><tt>texte</tt></b>)
</pre>

<p>où l'on insère le texte <i><tt>texte</tt></i> à l'emplacement de <i>bufferdetexte</i> spécifié par <i><tt>iter</tt></i>.</p>
<p>Si vous souhaitez simuler une insertion de texte par un utilisateur interactif, faites appel à la méthode suivante&nbsp;:</p>

<pre class=programlisting>
  resultat = bufferdetexte.insert_interactive(<b><tt>iter</tt></b>, <b><tt>texte</tt></b>, <b><tt>defaut_editable</tt></b>)
</pre>

<p>qui insèrera <i><tt>texte</tt></i> dans le buffer, à la position spécifiée par <i><tt>iter</tt></i>, mais seulement si cette position est éditable (c'est-à-dire si elle ne porte pas de balise mentionnant que le texte est non éditable) et que la valeur de <i><tt>defaut_editable</tt></i> est TRUE. Le résultat indique si le texte a été inséré.</p>
<p>L'argument <i><tt>defaut_editable</tt></i> précise si un texte peut être édité dans le cas où il ne porte pas de balise le spécifiant ; <i><tt>defaut_editable</tt></i> est généralement déterminé par un appel à la méthode <tt>get_editable</tt>() du <a title="13.2. TextView&nbsp;: la zone de texte" href="sec-TextViews.html"><tt>TextView</tt></a>.</p>
<p>D'autres méthodes existent pour insérer du texte&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.insert_at_cursor(<b><tt>texte</tt></b>)

  resultat = bufferdetexte.insert_at_cursor_interactive(<b><tt>texte</tt></b>, <b><tt>defaut_editable</tt></b>)

  bufferdetexte.insert_range(<b><tt>iter</tt></b>, <b><tt>debut</tt></b>, <b><tt>fin</tt></b>)

  resultat = bufferdetexte.insert_range_interactive(<b><tt>iter</tt></b>, <b><tt>debut</tt></b>, <b><tt>fin</tt></b>, <b><tt>defaut_editable</tt></b>)
</pre>

<p><tt>insert_at_cursor</tt>() est une méthode pratique pour insérer du texte à l'emplacement courant du curseur (<i><tt>insert</tt></i>).</p>
<p><tt>insert_range</tt>() copie le texte, les pixbufs et les balises compris entre les itérateurs <i><tt>debut</tt></i> et <i><tt>fin</tt></i> d'un <tt>TextBuffer</tt> (si ce <tt>TextBuffer</tt> n'est pas <i>bufferdetexte</i>, la table des balises doit être la même), puis colle le tout dans <i>bufferdetexte</i> à l'emplacement indiqué par <i><tt>iter</tt></i>.</p>

<p>Les versions interactives de ces méthodes opèrent de la même manière à la différence qu'elles n'insèrent la copie que si l'emplacement est éditable.</p>
<p>Enfin, en peut insérer du texte et lui appliquer des balises en même temps par l'intermédiaire des méthodes&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.insert_with_tags(iter, texte, balise1, balise2, ...)

  bufferdetexte.insert_with_tags_by_name(iter, texte, nom_balise1, nom_balise2, ...)
</pre>

<p><tt>insert_with_tags</tt>() insère le <i><tt>texte</tt></i> dans le <i>bufferdetexte</i>, à l'emplacement spécifié par l'<i><tt>iter</tt></i>, et lui applique les balises données.</p>
<p><tt>insert_with_tags_by_name</tt>() fait la même chose mais permet de spécifier les balises en les nommant.</p>
<p>On peut effacer du texte d'un buffer avec les méthodes&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.delete(<b><tt>debut</tt></b>, <b><tt>fin</tt></b>)

  resultat = bufferdetexte.delete_interactive(<b><tt>debut</tt></b>, <b><tt>fin</tt></b>, <b><tt>defaut_editable</tt></b>)
</pre>

<p><tt>delete</tt>() supprime le texte compris entre les <a title="13.4. TextIter&nbsp;: les itérateurs de texte" href="sec-TextIters.html"><tt>TextIter</tt></a> <i><tt>debut</tt></i> et <i><tt>fin</tt></i> de <i>bufferdetexte</i>.</p>
<p><tt>delete_interactive</tt>() supprime tout texte éditable (déterminé comme tel par les balises de texte applicables et par l'argument <i><tt>defaut_editable</tt></i>) compris entre <i><tt>debut</tt></i> et <i><tt>fin</tt></i>.</p>
<p>Vous pouvez récupérer une copie du texte d'un <tt>TextBuffer</tt> grâce aux méthodes&nbsp;:</p>

<pre class=programlisting>
  texte = bufferdetexte.get_text(<b><tt>debut</tt></b>, <b><tt>fin</tt></b>, <b><tt>include_hidden_chars</tt></b>=TRUE)

  texte = bufferdetexte.get_slice(<b><tt>debut</tt></b>, <b><tt>fin</tt></b>, <b><tt>include_hidden_chars</tt></b>=TRUE)
</pre>

<p><tt>get_text</tt>() retourne une copie du texte du buffer compris entre <i><tt>debut</tt></i> et <i><tt>fin</tt></i> ; le texte non affiché est exclu si <i><tt>include_hidden_chars</tt></i> vaut FALSE. Les caractères représentant des images incrustées ou des widgets sont exclus.</p>
<p><tt>get_slice</tt>() est identique à <tt>get_text</tt>() à la différence que le texte qu'elle retourne inclut un caractère 0xFFFC pour chaque image incrustée ou widget.</p></div>

<div class="sect2" lang="fr"><div class="titlepage">
<div><h3 class="title"><a name="CreerManipTextMark"></a>13.3.4. Créer et manipuler des TextMark</h3></div></div>

<p>Les <a title="13.5. TextMark&nbsp;: les marques de texte" href="sec-TextMarks.html"><tt>TextMark</tt></a> sont similaires aux <a title="13.4. TextIter&nbsp;: les itérateurs de texte" href="sec-TextIters.html"><tt>TextIter</tt></a> en ceci qu'elles spécifient une position entre deux caractères d'un <tt>TextBuffer</tt>. Cependant, les <a title="13.5. TextMark&nbsp;: les marques de texte" href="sec-TextMarks.html"><tt>TextMark</tt></a> maintiennent leur information de position même après modification du buffer. Les méthodes des <a title="13.5. TextMark&nbsp;: les marques de texte" href="sec-TextMarks.html"><tt>TextMark</tt></a> seront décrites plus loin dans la section <a title="13.5. TextMark&nbsp;: les marques de texte" href="sec-TextMarks.html"><tt>TextMark</tt></a>.</p>

<p>Un buffer de texte contient deux marques inhérentes&nbsp;: la marque <i><tt>insert</tt></i> (insertion) et la marque <i><tt>selection_bound</tt></i> (fin de sélection). La marque <i><tt>insert</tt></i> est la position par défaut pour l'insertion de texte (le curseur). La marque <i><tt>selection_bound</tt></i> se combine avec la marque <i><tt>insert</tt></i> pour définir une sélection.</p>

<p>On peut retrouver ces deux marques en faisant appel aux méthodes suivantes&nbsp;:</p>

<pre class=programlisting>
  marque_insert = bufferdetexte.get_insert()

  marque_selectionbound = bufferdetexte.get_selection_bound()
</pre>

<p>Les marques <i><tt>insert</tt></i> et <i><tt>selection_bound</tt></i> peuvent être placées simultanément à une position grâce à la méthode&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.place_cursor(<b><tt>emplacement</tt></b>)
</pre>

<p><i><tt>emplacement</tt></i> est un <a title="13.4. TextIter&nbsp;: les itérateurs de texte" href="sec-TextIters.html"><tt>TextIter</tt></a> qui indique la position. La méthode <tt>place_cursor</tt>() est nécessaire pour éviter de créer temporairement une sélection si les marques ont été déplacées individuellement.</p>

<p>On crée des <a title="13.5. TextMark&nbsp;: les marques de texte" href="sec-TextMarks.html"><tt>TextMark</tt></a> avec la méthode&nbsp;:</p>

<pre class=programlisting>
  marque = bufferdetexte.create_mark(<b><tt>nom_marque</tt></b>, <b><tt>emplacement</tt></b>, <b><tt>left_gravity</tt></b>=FALSE)
</pre>

<p>où <i><tt>nom_marque</tt></i> est le nom assigné à la marque créée (<tt>None</tt> pour une marque anonyme), <i><tt>emplacement</tt></i> est l'itérateur de texte indiquant la position de la marque dans le buffer, et <i><tt>left_gravity</tt></i> indique la situation de la marque après que du texte y aura été inséré (gauche si TRUE, droite si FALSE).</p>
<p>Une marque peut être déplacée dans le buffer avec les méthodes&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.move_mark(<b><tt>marque</tt></b>, <b><tt>emplacement</tt></b>)

  bufferdetexte.move_mark_by_name(<b><tt>nom_marque</tt></b>, <b><tt>emplacement</tt></b>)
</pre>

<p><i><tt>marque</tt></i> désigne la marque à déplacer. <i><tt>nom_marque</tt></i> spécifie le nom de la marque à déplacer. <i><tt>emplacement</tt></i> est un itérateur de texte indiquant la nouvelle position.</p>
<p>On peut supprimer une marque d'un buffer avec les méthodes&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.delete_mark(<b><tt>marque</tt></b>)

  bufferdetexte.delete_mark_by_name(<b><tt>nom_marque</tt></b>)
</pre>

<p>On peut récupérer une marque par son nom avec la méthode&nbsp;:</p>

<pre class=programlisting>
  marque = bufferdetexte.get_mark(<b><tt>nom_marque</tt></b>)
</pre>

</div>

<div class="sect2" lang="fr"><div class="titlepage">
<div><h3 class="title"><a name="CreerAppliqTextTag"></a>13.3.5. Créer et appliquer des TextTag</h3></div></div>

<p>Les <a title="13.6.1. Les TextTag" href="sec-TextTagsAndTextTagTables.html#TextTag"><tt>TextTag</tt></a> contiennent un ou plusieurs attributs (comme les couleurs d'arrière-plan et de premier plan, la police, la possibilité d'édition) que l'on peut appliquer à une ou plusieurs portions du texte d'un buffer. Les attributs pouvant être spécifiés par une <a title="13.6.1. Les TextTag" href="sec-TextTagsAndTextTagTables.html#TextTag"><tt>TextTag</tt></a> seront décrits dans la section <a title="13.6.1. Les TextTag" href="sec-TextTagsAndTextTagTables.html#TextTag"><tt>TextTag</tt></a>.</p>
<p>La méthode suivante crée une <a title="13.6.1. Les TextTag" href="sec-TextTagsAndTextTagTables.html#TextTag"><tt>TextTag</tt></a> avec des attributs et l'installe dans la <a title="13.6.2. La TextTagTable" href="sec-TextTagsAndTextTagTables.html#TextTagTable"><tt>TextTagTable</tt></a> d'un <tt>TextBuffer</tt>&nbsp;:</p>

<pre class=programlisting>
  balise = bufferdetexte.create_tag(name=None, attribut1=valeur1, attribut2=valeur2, ...)
</pre>

<p><i><tt>name</tt></i> est soit une chaîne de caractères spécifiant le nom de la balise, soit <tt>None</tt> si la balise est anonyme. Les couples <tt>attribut</tt>-<tt>valeur</tt> déterminent les attributs de la balise. Reportez-vous à la section <a title="13.6.1. Les TextTag" href="sec-TextTagsAndTextTagTables.html#TextTag"><tt>TextTag</tt></a> pour des informations concernant les attributs qui peuvent être définis par les propriétés d'une <a title="13.6.1. Les TextTag" href="sec-TextTagsAndTextTagTables.html#TextTag"><tt>TextTag</tt></a>.</p>
<p>Une balise peut être appliquée à une portion du texte d'un buffer par la méthode suivante&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.apply_tag(<b><tt>balise</tt></b>, <b><tt>debut</tt></b>, <b><tt>fin</tt></b>)

  bufferdetexte.apply_tag_by_name(<b><tt>nom_balise</tt></b>, <b><tt>debut</tt></b>, <b><tt>fin</tt></b>)
</pre>

<p>où <i><tt>balise</tt></i> est la balise à appliquer au texte, <i><tt>nom_balise</tt></i> le nom de la balise, et <i><tt>debut</tt></i> et <i><tt>fin</tt></i> des itérateurs de texte qui indiquent la portion de texte à laquelle la balise doit être appliquée.</p>
<p>On peut retirer une balise d'une portion de texte en utilisant les méthodes suivantes&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.remove_tag(<b><tt>balise</tt></b>, <b><tt>debut</tt></b>, <b><tt>fin</tt></b>)

  bufferdetexte.remove_tag_by_name(<b><tt>nom_balise</tt></b>, <b><tt>debut</tt></b>, <b><tt>fin</tt></b>)
</pre>

<p>Pour retirer toutes les balises d'une portion de texte, on utilisera&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.remove_all_tags(<b><tt>debut</tt></b>, <b><tt>fin</tt></b>)
</pre>

</div>

<div class="sect2" lang="fr"><div class="titlepage">
<div><h3 class="title"><a name="InserImagesWidgets"></a>13.3.6. Insérer des images et des widgets</h3></div></div>

<p>En plus du texte, un <tt>TextBuffer</tt> peut contenir des images pixbuf et un point d'ancrage pour widgets. Ce point d'ancrage sert à ajouter un widget à une <a title="13.2. TextView&nbsp;: la zone de texte" href="sec-TextViews.html"><tt>TextView</tt></a>. Un widget différent peut être ajouté dans chaque <a title="13.2. TextView&nbsp;: la zone de texte" href="sec-TextViews.html"><tt>TextView</tt></a> qui affiche un buffer contenant un point d'ancrage.</p>
<p>On peut insérer une image pixbuf avec la méthode suivante&nbsp;:</p>

<pre class=programlisting>
  bufferdetexte.insert_pixbuf(<b><tt>iter</tt></b>, <b><tt>pixbuf</tt></b>)
</pre>

<p>dans laquelle <i><tt>iter</tt></i> précise l'emplacement du buffer où insérer l'image <i><tt>pixbuf</tt></i>. Cette image comptera pour un caractère et sera représentée par le caractère Unicode "0xFFFC" dans le texte retourné par la méthode <tt>get_slice</tt>() (il ne figurera pas dans celui retourné par <tt>get_text</tt>() ).</p>
<p>On peut insérer un widget GTK+ dans une <a title="13.2. TextView&nbsp;: la zone de texte" href="sec-TextViews.html"><tt>TextView</tt></a>, &grave; un emplacement du buffer spécifiée par un <tt>TextChildAnchor</tt> (point d'ancrage pour enfant). Tout comme une image pixbuf, le <tt>TextChildAnchor</tt> comptera pour un caractère représenté par "0xFFFC".</p>
<p>Le moyen le plus commode de créer et d'insérer un <tt>TextChildAnchor</tt> est la méthode suivante&nbsp;:</p>

<pre class=programlisting>
  ancrage = bufferdetexte.create_child_anchor(<b><tt>iter</tt></b>)
</pre>

<p>où <i><tt>iter</tt></i> est l'emplacement destiné à recevoir le point d'ancrage.</p>
<p>Mais on peut aussi créer et insérer le <tt>TextChildAnchor</tt> en deux temps ainsi:</p>

<pre class=programlisting>
  ancrage = gtk.TextChildAnchor()

  bufferdetexte.insert_child_anchor(<b><tt>iter</tt></b>, <b><tt>ancrage</tt></b>)
</pre>

<p>Puis l'on peut ajouter le widget à la <a title="13.2. TextView&nbsp;: la zone de texte" href="sec-TextViews.html"><tt>TextView</tt></a>, au point d'ancrage, grâce à la méthode suivante&nbsp;:</p>

<pre class=programlisting>
  zonedetexte.add_child_at_anchor(<b><tt>widget_enfant</tt></b>, <b><tt>ancrage</tt></b>)
</pre>

<p>La méthode qui suit permet de récupérer la liste des widgets attachés à un point d'ancrage&nbsp;:</p>

<pre class=programlisting>
  liste_widgets = ancrage.get_widgets()
</pre>

<p>On peut également ajouter un widget à une <a title="13.2. TextView&nbsp;: la zone de texte" href="sec-TextViews.html"><tt>TextView</tt></a> en utilisant cette méthode&nbsp;:</p>

<pre class=programlisting>
  zonedetexte.add_child_in_window(<b><tt>widget_enfant</tt></b>, <b><tt>fenetre</tt></b>, <b><tt>position_x</tt></b>, <b><tt>position_y</tt></b>)
</pre>

<p>où le <i><tt>widget_enfant</tt></i> sera placé dans la fenêtre <i><tt>fenetre</tt></i> à la positon spécifiée par <i><tt>position_x</tt></i> et <i><tt>position_y</tt></i>. <i><tt>fenetre</tt></i> indique laquelle des fenêtres qui composent la <a title="13.2. TextView&nbsp;: la zone de texte" href="sec-TextViews.html"><tt>TextView</tt></a> doit recevoir le widget enfant&nbsp;:</p>

<pre class=programlisting>
  gtk.TEXT_WINDOW_TOP       # fenêtre supérieure
  gtk.TEXT_WINDOW_BOTTOM    # fenêtre inférieure
  gtk.TEXT_WINDOW_LEFT      # fenêtre de gauche
  gtk.TEXT_WINDOW_RIGHT     # fenêtre de droite
  gtk.TEXT_WINDOW_TEXT      # fenêtre du texte
  gtk.TEXT_WINDOW_WIDGET    # fenêtre du widget
</pre>

</div>
</div>

<div class=navfooter>
<hr>

<table width="100%" summary="Bas de page de navigation">

  <tr>
    <td align=left width="40%"><a accessKey=p href="sec-TextViews.html">Préc.</a>&nbsp;</td>
    <td align=center width="20%"><a accessKey=u href="ch-TextViewWidget.html">Chapitre parent</a></td>
    <td align=right width="40%">&nbsp;<a accessKey=n href="sec-TextIters.html">Suiv.</a></td></tr>
  <tr>
    <td vAlign=top align=left width="40%">13.2. TextView&nbsp;: la zone de texte&nbsp;</td>
    <td align=center width="20%"><a accessKey=h href="index.html">Table des matières</a></td>
    <td vAlign=top align=right width="40%">13.4. TextIter&nbsp;: les itérateurs de texte</td>
</tr></table>

</div>

</body>

</html>
