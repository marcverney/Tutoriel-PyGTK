<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
<title>14.10. TreeModelSort et TreeModelFilter</title>
<link rel="stylesheet" href="pygtktutfr.css">
<meta name="generator" content="Bluefish 1.0.5">
<meta name="keywords" content="python,pygtk,tutoriel,traduction,treeview" />
<link rel="start" href="index.html" title="Tutoriel PyGTK 2.0">
<link rel="up" href="ch-TreeViewWidget.html" title="Chapitre 14. Le widget TreeView">
<link rel="prev" href="sec-TreeViewDragAndDrop.html" title="14.9. Glisser-déposer dans un TreeView">
<link rel="next" href="sec-GenericTreeModel.html" title="14.11. Le TreeModel générique">
</head>
<body>
<div class="localisation">
Vous êtes à peu près ici :
<a href="../../index.html">Accueil</a>&nbsp;  &raquo;  &nbsp;
<a href="../pygtktut.php">tutoriel PyGTK</a>&nbsp; &raquo; &nbsp;
 <a href="index.html">PyGTK : sommaire</a>
</div> <!-- fin localisation -->
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">14.10. TreeModelSort et TreeModelFilter</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="sec-TreeViewDragAndDrop.html">Préc.</a> </td>
<th width="60%" align="center">Chapitre 14. Le widget TreeView</th>
<td width="20%" align="right"> <a accesskey="n" href="sec-GenericTreeModel.html">Suiv.</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1" lang="fr">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="sec-TreeModelSortAndTreeModelFilter"></a>14.10. TreeModelSort et TreeModelFilter</h2></div></div></div>
<p>Les <code class="classname">TreeModelSort</code> et <code class="classname">TreeModelFilter</code>
sont des modèles d'arbre qui s'intercalent entre le <code class="classname">TreeModel</code>
de base (un <code class="classname">TreeStore</code> ou un <code class="classname">ListStore</code>)
et le <code class="classname">TreeView</code> pour fournir un modèle modifié en conservant
la structure d'origine du modèle de base. Ces modèles interposables implémentent
les interfaces <code class="classname">TreeModel</code> et <code class="classname">TreeSortable</code>
mais ne fournissent aucune méthode pour insérer ou retirer des lignes dans le
modèle, il faut insérer ou retirer ces lignes dans le magasin de données sous-jacent.
Le <code class="classname">TreeModelSort</code> fournit un modèle dans lequel les lignes
sont toujours classées, le <code class="classname">TreeModelFilter</code> fournit un modèle
contenant un sous-ensemble des lignes du modèle de base.
</p>
<p>Ces modèles peuvent être reliés sur une longueur arbitraire, si désiré. Par
exemple, un <code class="classname">TreeModelFilter</code> peut avoir un enfant
<code class="classname">TreeModelSort</code> qui peut peut avoir un enfant
<code class="classname">TreeModelFilter</code> et ainsi de suite. Tant qu'il existe
un <code class="classname">TreeStore</code> ou un <code class="classname">ListStore</code>
comme point de départ de la chaine, cela devrait fonctionner. Sous
PyGTK :2.0 et 2.2 les objets <code class="classname">TreeModelSort</code> et
<code class="classname">TreeModelFilter</code> ne fonctionnent pas avec le protocole
de mappage (mise en correspondance) de Python.
</p>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-TreeModelSort"></a>14.10.1. Le TreeModelSort</h3></div></div></div>
<p>Le <code class="classname">TreeModelSort</code> maintient un modèle trié du modèle
enfant indiqué dans son constructeur. L'usage principal du
<code class="classname">TreeModelSort</code> est de fournir, pour un modele,
des vues multiples qui peuvent être classées diversement. Lorsque l'on a plusieurs
vues d'un même modèle, toute opération de tri se répercute dans toutes les vues.
Utiliser le <code class="classname">TreeModelSort</code> permet de laisser le modèle
de départ dans son état originel pendant que les modèles de tri absorbent
toutes les opérations de tri. Pour créer un <code class="classname">TreeModelSort</code>,
il faut utiliser le constructeur :
</p>
<pre class="programlisting">
  treemodelsort = gtk.TreeModelSort(<strong class="parameter"><code>child_model</code></strong>)
</pre>
<p>... où <em class="parameter"><code>child_model</code></em> est un
<code class="classname">TreeModel</code>. La plupart des méthodes du
<code class="classname">TreeModelSort</code> portent sur la conversion des chemins de
l'arborescence et des <code class="classname">TreeIter</code> du modèle enfant
vers le modèle trié, et réciproquement :

</p>
<pre class="programlisting">
  sorted_path = treemodelsort.convert_child_path_to_path(<strong class="parameter"><code>child_path</code></strong>)
  child_path = treemodelsort.convert_path_to_child_path(<strong class="parameter"><code>sorted_path</code></strong>)
</pre>
<p>Ces méthodes de conversion de chemin renvoient <code class="literal">None</code> si
le chemin donné ne peut être converti en chemin dans le modèle trié
ou dans le modèle enfant. Les méthodes de conversion du
<code class="classname">TreeIter</code> sont :
</p>
<pre class="programlisting">
  sorted_iter = treemodelsort.convert_child_iter_to_iter(<strong class="parameter"><code>sorted_iter</code></strong>, <strong class="parameter"><code>child_iter</code></strong>)
 child_iter = treemodelsort.convert_iter_to_child_iter(<strong class="parameter"><code>child_iter</code></strong>, <strong class="parameter"><code>sorted_iter</code></strong>)
</pre>
<p>Les méthodes de conversion du <code class="classname">TreeIter</code> dupliquent
l'argument converti (la valeur de retour comme le premier argument) pour
une présever une compatibilité antérieure. Il faut donner la valeur
<code class="literal">None</code> au premier argument et n'utiliser que la valeur
de retour. Par exemple :
</p>
<pre class="programlisting">
  sorted_iter = treemodelsort.convert_child_iter_to_iter(None, child_iter)
  child_iter = treemodelsort.convert_iter_to_child_iter(None, sorted_iter)
</pre>
<p>Comme les méthodes de conversion du chemin, ces méthodes renvoient
<code class="literal">None</code> si le <code class="classname">TreeIter</code> indiqué ne
peut être converti.
</p>
<p>On peut retrouver le <code class="classname">TreeModel</code> enfant gràce à la
méthode <code class="methodname">get_model</code>().
</p>
<p><a href="exemples/treemodelsort.py" target="_top">treemodelsort.py</a> est un exemple
simple utilisant les objets du <code class="classname">TreeModelSort</code>. Les
résultats obtenus avec 6 lignes sont illustrés par
<a href="sec-TreeModelSortAndTreeModelFilter.html#treemodelsortfig" title="Figure 14.9. Exemple de TreeModelSort">Figure 14.9, « Exemple de TreeModelSort »</a>
</p>
<div class="figure">
<a name="treemodelsortfig"></a><p class="title"><b>Figure 14.9. Exemple de TreeModelSort</b></p>
<div class="mediaobject" align="center"><img src="figures/treemodelsort.png" align="middle" alt="Exemple de TreeModelSort."></div>
</div>
<p>Chacune des colonnes d'une fenêtre peut être réordonnée avec un click sur
son titre indépendamment des autres fenêtres. Lorsque le bouton
"<span class="guibutton">Add a Row</span>" est pressé, une nouvelle ligne est
ajoutée dans le <code class="classname">ListStore</code> de base et cette
nouvelle ligne est affichée dans chaque fenêtre comme étant la ligne
sélectionnée.
</p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-TreeModelFilter"></a>14.10.2. Le TreeModelFilter</h3></div></div></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>Le <code class="classname">TreeModelFilter</code> est disponible
avec PyGTK 2.4 et supérieur.</p>
</div>
<p>Un objet <code class="classname">TreeModelFilter</code> fournit plusieurs façons
de modifier la vue du <code class="classname">TreeModel</code> de base, y compris :

</p>
<div class="itemizedlist"><ul type="disc">
<li>afficher un sous-ensemble de lignes dans le modèle fils basé soit sur la
valeur booléenne d'une "colonne visible" soit sur la valeur booléenne de retour
 d'une "fonction visible" ayant comme arguments un modèle fils, un <code class="classname">TreeIter</code>
pointant sur une ligne du modèle fils et des données utilisateurs. Dans les deux cas,
si la valeur booléenne vaut <code class="literal">TRUE</code>, la ligne est affichée sinon elle
est cachée.
</li>
<li>utiliser une racine virtuelle qui fournit une vue d'un sous-arbre des
enfants d'une ligne dans un modele fils. Ceci n'est réalisable que si les
données sont dans un <code class="classname">TreeStore</code>.
</li>
<li>combiner les colonnes et données d'un modèle relativement aux données du
modèle fils. Par exemple, on peut afficher une colonne dans laquelle les
données sont calculées à partir de données dans plusieurs colonnes du
modèle fils.
</li>
</ul></div>
<p>Un objet <code class="classname">TreeModelFilter</code> est crée par la méthode
<code class="classname">TreeModel</code> :
</p>
<pre class="programlisting">
  treemodelfilter = treemodel.filter_new(<strong class="parameter"><code>root</code></strong>=None)
</pre>
<p>... où <em class="parameter"><code>root</code></em> est un chemin dans l'arbre du
<em class="parameter"><code>treemodel</code></em> précisant une racine virtuelle du modèle
ou <code class="literal">None</code> si la racine du <em class="parameter"><code>treemodel</code></em> doit
être utilisée.
</p>
<p>Indiquer une "racine virtuelle" quand on crée le
<code class="classname">TreeModelFilter</code> permet de limiter la vue aux
enfants de cette ligne "racine" dans la hiérarchie du modèle fils. Ceci, bien
sûr, n'est utile que si le modèle fils est basé sur un <code class="classname">TreeStore</code>.
Par exemple, on peut vouloir fournir une vue de la liste des pièces qui
composent un lecteur de CDROM distincte de la liste complète des pièces
de l'ordinateur.
</p>
<p>Les modes de visibilité sont mutuellement exclusifs et ne peuvent être
fixés qu'une seule fois ; Une fois la visibilité de la colonne ou de la
fonction établie, on ne peut plus la modifier et l'autre mode ne peut plus
être utilisé. Le mode de visibilité le plus simple extrait une valeur
booléenne d'une colonne du modèle fils pour déterminer si la ligne
doit être affichée. La visibilité colonne est fixée par :
</p>
<pre class="programlisting">
  treemodelfilter.set_visible_column(<strong class="parameter"><code>column</code></strong>)
</pre>
<p>... où <em class="parameter"><code>column</code></em> est le numéro de la colonne dans le
<code class="classname">TreeModel</code> fils, de laquelle extraire les
valeurs booléennes. Par exemple, le code suivant utilise les valeurs de la
troisième colonne pour fixer la visibilité des lignes :
</p>
<pre class="programlisting">
  ...
  treestore = gtk.TreeStore(str, str, "gboolean")
  ...
  modelfilter = treestore.filter_new()
  modelfilter.set_visible_column(2)
  ...
</pre>
<p>Ainsi, toutes les lignes du <em class="parameter"><code>treestore</code></em> qui possèdent
la valeur <code class="literal">TRUE</code> dans la troisième colonne seront affichées.
</p>
<p>Si on veut utiliser des critères de visibilité plus complexes, une fonction
visibilité devrait fournir des capacités suffisantes :
</p>
<pre class="programlisting">
  treemodelfilter.set_visible_func(<strong class="parameter"><code>func</code></strong>, <strong class="parameter"><code>data</code></strong>=None)
</pre>
<p>... où <em class="parameter"><code>func</code></em> est la fonction appelée pour chaque
ligne du modèle fils afin de décider si elle doit être affichée et
<em class="parameter"><code>data</code></em> représente les données utilisateur transmises
à la fonction <em class="parameter"><code>func</code></em>. La fonction <em class="parameter"><code>func</code></em>
renvoie <code class="literal">TRUE</code> si la ligne doit être affichée. Cette fonction
a pour signature :
</p>
<pre class="programlisting">
  def func(<em class="parameter"><code>modele</code></em>, <em class="parameter"><code>iter</code></em>, <em class="parameter"><code>donnees_utilisateur</code></em>)
</pre>
<p>... où <em class="parameter"><code>modele</code></em> est le <code class="classname">TreeModel</code>
fils, <em class="parameter"><code>iter</code></em> est un <code class="classname">TreeIter</code>
pointant sur une ligne du <em class="parameter"><code>modele</code></em> et
<em class="parameter"><code>donnees_utilisateur</code></em> sont les <em class="parameter"><code>data</code></em>
passées dans la fonction.
</p>
<p>Si on modifie le critère de visibilité, il faut utiliser :
</p>
<pre class="programlisting">
  treemodelfilter.refilter()
</pre>
<p>pour imposer un nouveau filtrage des lignes du modèle fils.
</p>
<p>Par exemple, l'extrait de code ci-dessous illustre un
<code class="classname">TreeModelFilter</code> qui affiche des lignes selon une
comparaison entre la valeur de la troisième colonne et le contenu des
données utilisateurs :
</p>
<pre class="programlisting">
  ...
  def match_type(modele, iter, donnees_utilisateur):
      valeur = model.get_value(iter, 2)
      return valeur in donnees_utilisateur
  ...
  show_vals = ['OPEN', 'NEW', 'RESO']
  liststore = gtk.ListStore(str, str, str)
  ...
  modelfilter = liststore.filter_new()
  modelfilter.set_visible_func(match_type, show_vals)
  ...
</pre>
<p>Le programme <a href="exemples/treemodelfilter.py" target="_top">treemodelfilter.py</a> illustre
l'utilisation de la méthode <code class="methodname">set_visible_func</code>().
<a href="sec-TreeModelSortAndTreeModelFilter.html#treemodelfilterfig" title="Figure 14.10. Exemple de visibilité d'un TreeModelFilter">Figure 14.10, « Exemple de visibilité d'un TreeModelFilter »</a> montre le résultat obtenu.
</p>
<div class="figure">
<a name="treemodelfilterfig"></a><p class="title"><b>Figure 14.10. Exemple de visibilité d'un TreeModelFilter</b></p>
<div class="mediaobject" align="center"><img src="figures/treemodelfilter.png" align="middle" alt="Exemple de TreeModelFilter."></div>
</div>
<p>En agissant sur les boutons du bas, on modifie le contenu du
<code class="classname">TreeView</code> pour afficher seulement les lignes
qui correspondent à l'étiquette du bouton.
</p>
<p>Une fonction modify permet un autre niveau de contrôle sur l'affichage du
<code class="classname">TreeView</code> sur la manière dont on peut combiner
une ou plusieurs (ou toutes) colonnes présentées par le
<code class="classname">TreeModelFilter</code>. Il faut utiliser un modèle fils de
base, un <code class="classname">TreeStore</code> ou un <code class="classname">ListStore</code>
pour déterminer le nombre de lignes et la hiérarchie, mais les colonnes peuvent
être tout ce qui est indiqué dans la méthode :

</p>
<pre class="programlisting">
  treemodelfilter.set_modify_func(<strong class="parameter"><code>types</code></strong>, <strong class="parameter"><code>func</code></strong>, <strong class="parameter"><code>data</code></strong>=None)
</pre>
<p>... où <em class="parameter"><code>types</code></em> est une suite (liste ou tuple) précisant
le type de colonne présentes, <em class="parameter"><code>func</code></em> est une fonction
appelée pour renvoyer la valeur pour une rangée et une colonne et
<em class="parameter"><code>data</code></em> est un argument passé à la fonction
<em class="parameter"><code>func</code></em>. La fonction <em class="parameter"><code>func</code></em>
a pour signature :
</p>
<pre class="programlisting">
  def func(<em class="parameter"><code>modele</code></em>, <em class="parameter"><code>iter</code></em>, <em class="parameter"><code>colonne</code></em>, <em class="parameter"><code>donnees_utilisateur</code></em>)
</pre>
<p>...où <em class="parameter"><code>modele</code></em> est le <code class="classname">TreeModelFilter</code>,
<em class="parameter"><code>iter</code></em> le <code class="classname">TreeIter</code> qui pointe sur
une ligne du modele, <em class="parameter"><code>colonne</code></em> est le numéro de la colonne
pour laquelle une valeur est nécessaire et <em class="parameter"><code>donnees_utilisateur</code></em>
est le paramètre <em class="parameter"><code>data</code></em>. La fonction
<em class="parameter"><code>func</code></em> doit renvoyer une valeur correspondant au type de
<em class="parameter"><code>colonne</code></em>.
</p>
<p>Une fonction de modification est utile quand on souhaite fournir une colonne
de données qui doivent être générées à partir de données de colonnes du modèle
fils. Par exemple, on dispose d'une colonne contenant des dates de naissance
et on veut fournir une colonne affichant les âges ; une fonction de modification
peut générer l'information sur l'âge à partir de la date de naissance et de la date
actuelle. Un autre exemple serait de choisir l'image à afficher selon l'analyse
des données (un nom de fichier) dans une colonne. Cette action peut aussi être
réalisée par la methode <code class="methodname">set_cell_data_func</code>() du
<code class="classname">TreeViewColumn</code>.
</p>
<p>Généralement, avec la fonction modify, il faut convertir le
<code class="classname">TreeIter</code> du <code class="classname">TreeModelFilter</code> en
un <code class="classname">TreeIter</code> dans le modèle fils par :
</p>
<pre class="programlisting">
  child_iter = treemodelfilter.convert_iter_to_child_iter(<strong class="parameter"><code>filter_iter</code></strong>)
</pre>
<p>Bien sûr, il faut aussi retrouver le modèle fils par :</p>
<pre class="programlisting">
  child_model = treemodelfilter.get_model()
</pre>
<p>Ceci donne accès à la ligne du modèle fils et à son contenu pour fournir la
valeur de la ligne et colonne indiquées du <code class="classname">TreeModelFilter</code>.
Il existe aussi une méthode pour convertir les chemins du modèle filtre de et vers
les chemins de l'arborescence fille.
</p>
<pre class="programlisting">
  filter_iter = treemodelfilter.convert_child_iter_to_iter(<strong class="parameter"><code>child_iter</code></strong>)

  child_path = treemodelfilter.convert_path_to_child_path(<strong class="parameter"><code>filter_path</code></strong>)
  filter_path = treemodelfilter.convert_child_path_to_path(<strong class="parameter"><code>child_path</code></strong>)
</pre>
<p>Bien sûr, il est possible de combiner les modes de visibilité et la fonction
modify pour, à la fois, filtrer les lignes et produire les colonnes. Pour
obtenir encore plus de contrôle sur la vue, il faudrait utiliser un
<code class="classname">TreeModel</code> personnalisé.
</p>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="sec-TreeViewDragAndDrop.html">Préc.</a> </td>
<td width="20%" align="center"><a accesskey="u" href="ch-TreeViewWidget.html">Chapitre parent</a></td>
<td width="40%" align="right"> <a accesskey="n" href="sec-GenericTreeModel.html">Suiv.</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">14.9. Glisser-déposer dans un TreeView </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Table des matières</a></td>
<td width="40%" align="right" valign="top"> 14.11. Le TreeModel générique</td>
</tr>
</table>
</div>
</body>
</html>
