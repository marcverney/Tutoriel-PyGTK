<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>14.11. Le TreeModel générique</title>
<link rel="stylesheet" href="pygtktutfr.css" type="text/css">
<meta name="generator" content="Bluefish 1.0.5">
<meta name="keywords" content="python,pygtk,tutoriel,traduction,treeview" />
<link rel="start" href="index.html" title="Tutoriel PyGTK 2.0">
<link rel="up" href="ch-TreeViewWidget.html" title="Chapitre 14. Le widget TreeView">
<link rel="prev" href="sec-TreeModelSortAndTreeModelFilter.html" title="14.10. TreeModelSort et TreeModelFilter">
<link rel="next" href="sec-GenericCellRenderer.html" title="14.12. The Generic CellRenderer">
</head>
<body>
<div class="localisation"> 
Vous êtes à peu près ici : 
<a href="../../index.html">Accueil</a>&nbsp;  &raquo;  &nbsp;
<a href="../pygtktut.php">tutoriel PyGTK</a>&nbsp; &raquo; &nbsp;
 <a href="index.html">PyGTK : sommaire</a>
</div> <!-- fin localisation --> 
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">14.11. Le TreeModel générique</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="sec-TreeModelSortAndTreeModelFilter.html">Préc.</a> </td>
<th width="60%" align="center">Chapitre 14. Le widget TreeView</th>
<td width="20%" align="right"> <a accesskey="n" href="sec-GenericCellRenderer.html">Suiv.</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1" lang="fr">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="sec-GenericTreeModel"></a>14.11. Le TreeModel générique</h2></div></div></div>
<p>Si le <code class="classname">TreeModel</code> standard n'est pas assez puissant pour 
les besoins de l'application, il est possible d'utiliser le 
<code class="classname">GenericTreeModel</code> pour construire son propre 
<code class="classname">TreeModel</code> personnalisé en python. Créer un 
<code class="classname">GenericTreeModel</code> peut être utile en cas de problème de 
performance avec les objets <code class="classname">TreeStore</code> et 
<code class="classname">ListStore</code> standards, ou si on veut une interface 
directe avec une source de données externe (une base de données ou un système 
de fichiers) pour éviter une duplication des données de et vers le 
<code class="classname">TreeStore</code> ou le <code class="classname">ListStore</code>.
</p>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-GenericTreeModelOverview"></a>14.11.1. Aperçu du GenericTreeModel</h3></div></div></div>
<p>Avec un <code class="classname">GenericTreeModel</code>, on construit et gère son 
modèle de données et on fournit un accès externe à travers l'interface du 
<code class="classname">TreeModel</code> standard en définissant un ensemble de 
méthodes de classe. PyGTK implémente l'interface du 
<code class="classname">TreeModel</code> et prend en charge les méthodes du 
<code class="classname">TreeModel</code> appelées pour fournir le modèle de données 
réel.
</p>
<p>Les détails de l'implémentation de votre modèle devraient rester complétement 
cachés aux applications externes. Ce qui signifie que la manière dont votre 
modèle identifie, range et retrouve les données n'est pas connue de 
l'application. En général, la seule information qui est sauvegardée en-dehors 
du <code class="classname">GenericTreeModel</code> sont les références de ligne qui sont 
enveloppées par les <code class="classname">TreeIter</code> externes. Ces références ne 
sont pas visibles par l'application.
</p>
<p>Voici un examen détaillé de l'interface <code class="classname">GenericTreeModel</code> 
qu'il faut fournir.
</p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-GenericTreeModelInterface"></a>14.11.2. Interface du GenericTreeModel</h3></div></div></div>
<p>L'interface du <code class="classname">GenericTreeModel</code> comprend les 
méthodes suivantes qui doivent être implémentées dans le modèle 
personnalisé :
</p>
<code class="methodsynopsis">    def <span class="methodname">on_get_flags</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">on_get_n_columns</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">on_get_column_type</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>index</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">on_get_iter</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>path</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">on_get_path</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>rowref</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">on_get_value</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>rowref</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>column</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">on_iter_next</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>rowref</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">on_iter_children</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>parent</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">on_iter_has_child</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>rowref</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">on_iter_n_children</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>rowref</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">on_iter_nth_child</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>parent</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>n</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">on_iter_parent</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>self</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>child</code></em></span></span>)</code><br><p>Il faut remarquer que ces méthodes supportent entièrement l'interface du 
<code class="classname">TreeModel</code>, y compris :
</p>
<code class="methodsynopsis">    def <span class="methodname">get_flags</span>(<span class="methodparam"></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">get_n_columns</span>(<span class="methodparam"></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">get_column_type</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>index</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">get_iter</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>path</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">get_iter_from_string</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>path_string</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">get_string_from_iter</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>iter</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">get_iter_root</span>(<span class="methodparam"></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">get_iter_first</span>(<span class="methodparam"></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">get_path</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>iter</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">get_value</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>iter</code></strong></span></span>, <span class="methodparam"><span class="parameter"><strong class="parameter"><code>column</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">iter_next</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>iter</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">iter_children</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>parent</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">iter_has_child</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>iter</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">iter_n_children</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>iter</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">iter_nth_child</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>parent</code></strong></span></span>, <span class="methodparam"><span class="parameter"><strong class="parameter"><code>n</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">iter_parent</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>child</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">get</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>iter</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>column</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>...</code></em></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">foreach</span>(<span class="methodparam"><span class="parameter"><em class="parameter"><code>func</code></em></span></span>, <span class="methodparam"><span class="parameter"><em class="parameter"><code>user_data</code></em></span></span>)</code><p>Pour illustrer l'utilisation du <code class="classname">GenericTreeModel</code> 
j'ai modifié le programme <a href="exemples/listefichiers.py" target="_top"><span><strong class="command">listefichiers.py</strong></span></a> et 
montre comment les méthodes d'interface sont réalisées. Le programme 
<a href="exemples/listefichiers-gtm.py" target="_top"><span><strong class="command">listefichiers-gtm.py</strong></span></a> 
affiche les fichiers d'un répertoire avec une icône indiquant si le fichier est ou 
non un répertoire, le nom du fichier,  sa taille, son mode et sa date de dernière 
modification.
</p>
<p>La méthode <code class="methodname">on_get_flags</code>() doit retourner une 
valeur qui est une combinaison de  :
</p>
<table border="0" width="100%" bgcolor="#FFECCE">
<col align="left" valign="top" width="0*">
<tbody>
<tr>
<td>
<span class="term"><code class="literal">gtk.TREE_MODEL_ITERS_PERSIST</code></span></td>
<td>Les <code class="classname">TreeIter</code> perdurent quels que soient 
les signaux émis par l'arbre.</td>
</tr>
<tr>
<td>
<span class="term"><code class="literal">gtk.TREE_MODEL_LIST_ONLY</code></span></td>
<td>Le modèle est uniquement une liste et n'a jamais d'enfant.
</td>
</tr>
</tbody>
</table>
<p>Si  un modèle posséde des références de lignes valides malgré les changements 
de lignes (réordonnancement, ajout, suppression), on utilise 
<code class="literal">gtk.TREE_MODEL_ITERS_PERSIST</code>. De la même façon, si un 
modèle est seulement une liste, on utilise <code class="literal">gtk.TREE_MODEL_LIST_ONLY</code>. 
Autrement, on renvoie 0 si le modèle ne possède pas de références de lignes 
persistantes et est une arborescence. Dans l'exemple, le modèle est une liste 
avec des <code class="classname">TreeIter</code> persistants.
</p>
<pre class="programlisting">
    def on_get_flags(self):
        return gtk.TREE_MODEL_LIST_ONLY|gtk.TREE_MODEL_ITERS_PERSIST
</pre>
<p>La méthode <code class="methodname">on_get_n_columns</code>() doit retourner le 
nombre de colonnes que le modèle exporte vers l'application. L'exemple 
garde une liste de types de colonnes, ainsi on peut renvoyer la longueur 
de la liste :
</p>
<pre class="programlisting">
class Fichmodeleliste(gtk.GenericTreeModel):
    ...
    column_types = (gtk.gdk.Pixbuf, str, long, str, str)
    ...
    def on_get_n_columns(self):
        return len(self.types_colonnes)
</pre>
<p>La méthode <code class="methodname">on_get_column_type</code>() doit renvoyer le type 
de la colonne pour l'<em class="parameter"><code>index</code></em> indiqué. Cette méthode est généralement 
appelée par un <code class="classname">TreeView</code> quand le modèle est établi. 
On peut soit créer une liste ou un tuple contenant l'information de type de colonne 
soit le créer à la volée. Dans l'exemple :
</p>
<pre class="programlisting">
    def on_get_column_type(self, n):
        return self.types_colonnes[n]
</pre>
<p>L'interface <code class="classname">GenericTreeModel</code> convertit le type 
Python en un GType, donc le code suivant</p>
<pre class="programlisting">
  flm = Fichmodeleliste()
  print flm.on_get_column_type(1), flm.get_column_type(1)
</pre>
<p>imprimerait :</p>
<pre class="programlisting">
&lt;type 'str'&gt; &lt;GType gchararray (64)&gt;
</pre>
<p>Les méthodes suivantes utilisent les références de ligne qui sont conservées 
comme données privées dans un <code class="classname">TreeIter</code>. L'application 
ne peut lire la référence de ligne dans un <code class="classname">TreeIter</code> 
donc on peut utiliser n'importe quel item unique voulu comme référence de 
ligne. Par exemple, dans un modèle comportant des lignes comme des tuples, il 
est possible d'utiliser l'index de tuple comme la référence de ligne. Un 
autre exemple serait d'utiliser un nom de fichier comme référence de ligne 
dans un modèle représentant des fichiers dans un répertoire. Dans ces deux 
cas, le référence de ligne n'est pas modifiée par les changements du modèle, 
aussi les <code class="classname">TreeIter</code> peuvent être déclarés persistants. 
L'interface de l'application PyGTK <code class="classname">GenericTreeModel</code> 
extraira vos références de ligne à partir des <code class="classname">TreeIter</code> 
et enveloppera vos références de ligne dans les <code class="classname">TreeIter</code> 
selons les besoins.
</p>
<p>Dans les méthodes suivantes, <code class="literal">refligne</code> se réfère à une 
référence de ligne interne.</p>
<p>La méthode <code class="methodname">on_get_iter</code>() devrait renvoyer un refligne 
pour le chemin de l'arborescence indiqué par le <em class="parameter"><code>chemin</code></em>. 
Le chemin de l'arborescence doit toujours être représenté par un tuple. L'exemple 
utilise le nom de fichier comme refligne. Les noms de fichier sont conservés dans 
une liste dans le modèle, ainsi on prend le premier index du chemin comme index 
du nom de fichier :
</p>
<pre class="programlisting">
    def on_get_iter(self, chemin):
        return self.fichiers[chemin[0]]
</pre>
<p>Il faut être cohérent dans l'utilisation de la référence de ligne puisque on 
récupérera une référence de ligne dans les appels de méthode des méthodes 
<code class="classname">GenericTreeModel</code> qui prennent les arguments 
<code class="classname">TreeIter</code> :
<code class="methodname">on_get_path</code>(),
<code class="methodname">on_get_value</code>(),
<code class="methodname">on_iter_next</code>(),
<code class="methodname">on_iter_children</code>(),
<code class="methodname">on_iter_has_child</code>(),
<code class="methodname">on_iter_n_children</code>(),
<code class="methodname">on_iter_nth_child</code>() et
<code class="methodname">on_iter_parent</code>().</p>
<p>La méthode <code class="methodname">on_get_path</code>() devrait retourner un chemin 
de l'arborescence donnant un <em class="parameter"><code>refligne</code></em>. Par exemple, poursuivant l'exemple précédent 
où le nom de fichier est utilisé comme <em class="parameter"><code>refligne</code></em>, on pourrait définir la méthode 
<code class="methodname">on_get_path</code>() comme suit :
</p>
<pre class="programlisting">
    def on_get_chemin(self, refligne):
        return self.fichiers.index(refligne)
</pre>
<p>Cette méthode trouve l'index de la liste contenant le nom de fichier dans 
<em class="parameter"><code>refligne</code></em>. Cet exemple montre clairement qu'un choix 
judicieux de référence de ligne rend l'exécution plus efficiente. Par exemple, 
on pourrait utiliser un dictionnaire Python pour relier 
<em class="parameter"><code>refligne</code></em> à un chemin.
</p>
<p>La méthode <code class="methodname">on_get_value</code>() devrait renvoyer les 
données rangées à la ligne et colonne indiquées par <em class="parameter"><code>refligne</code></em> 
et <em class="parameter"><code>colonne</code></em>. Dans l'exemple :
</p>
<pre class="programlisting">
    def on_get_value(self, refligne, colonne):
        fname = os.path.join(self.nomrep, refligne)
        try:
            statutfich = os.stat(fname)
        except OSError:
            return None
        mode = statutfich.st_mode
        if colonne is 0:
            if stat.S_ISDIR(mode):
                return dossierpb
            else:
                return fichierpb
        elif colonne is 1:
            return refligne
        elif colonne is 2:
            return statutfich.st_size
        elif colonne is 3:
            return oct(stat.S_IMODE(mode))
        return time.ctime(statutfich.st_mtime)
</pre>
<p>on doit extraire l'information de fichier associée et renvoyer la valeur 
appropriée selon la colonne indiquée.
</p>
<p>La méthode <code class="methodname">on_iter_next</code>() devrait retourner une 
référence de ligne à la ligne (de même niveau) après la ligne indiquée 
par <em class="parameter"><code>refligne</code></em>. Dans l'exemple :
</p>
<pre class="programlisting">
    def on_iter_next(self, refligne):
        try:
            i = self.fichiers.index(refligne)+1
            return self.fichiers[i]
        except IndexError:
            return None
</pre>
<p>L'index du nom de fichier de <em class="parameter"><code>refligne</code></em> est établi  
et le nom de fichier suivant est renvoyé ou s'il n'existe pas, 
<code class="literal">None</code> est renvoyé.
</p>
<p>La méthode <code class="methodname">on_iter_children</code>() devrait retourner une 
référence de ligne vers la première ligne enfant de la ligne indiquée par 
<em class="parameter"><code>refligne</code></em>. Si <em class="parameter"><code>refligne</code></em> vaut 
<code class="literal">None</code>, une référence à la première ligne du niveau 
supérieur est retournée. S'il n'existe pas de ligne enfant, 
<code class="literal">None</code> est retourné. Dans l'exemple :
</p>
<pre class="programlisting">
    def on_iter_children(self, refligne):
        if refligne:
            return None
        return self.fichiers[0]
</pre>
<p>Puisque le modèle est une liste, seul le niveau supérieur 
(<em class="parameter"><code>refligne</code></em>=<code class="literal">None</code>) peut posséder 
des lignes enfant. <code class="literal">None</code> est retourné si 
<em class="parameter"><code>refligne</code></em> contient un nom de fichier.
</p>
<p>La méthode <code class="methodname">on_iter_has_child</code>() doit renvoyer 
<code class="literal">TRUE</code> si la ligne indiquée par <em class="parameter"><code>refligne</code></em> 
possède des lignes enfant, <code class="literal">FALSE</code> sinon. Dans l'exemple, on renvoie 
<code class="literal">FALSE</code> puisque aucune ligne ne peut posséder d'enfant :
</p>
<pre class="programlisting">
    def on_iter_has_child(self, refligne):
        return False
</pre>
<p>La méthode <code class="methodname">on_iter_n_children</code>() renvoie le nombre 
de lignes enfant que posséde la ligne indiquée par <em class="parameter"><code>refligne</code></em>. 
Si <em class="parameter"><code>refligne</code></em> vaut <code class="literal">None</code>, on renvoie le 
nombre de lignes du niveau supérieur. Dans l'exemple, on renvoie 0 si 
<em class="parameter"><code>refligne</code></em> ne vaut pas <code class="literal">None</code> :
</p>
<pre class="programlisting">
    def on_iter_n_children(self, refligne):
        if refligne:
            return 0
        return len(self.fichiers)
</pre>
<p>La méthode <code class="methodname">on_iter_nth_child</code>() renvoie une 
référence de ligne à la énième ligne enfant de la ligne indiquée par 
<em class="parameter"><code>parent</code></em>. Si <em class="parameter"><code>parent</code></em> vaut 
<code class="literal">None</code>, une référence à la énième ligne du niveau 
supérieur est retournée. Dans l'exemple, on retourne une référence à 
la énième ligne du niveau supérieur si <em class="parameter"><code>parent</code></em> 
vaut <code class="literal">None</code>, <code class="literal">None</code> sinon :
</p>
<pre class="programlisting">
    def on_iter_nth_child(self, refligne, n):
        if refligne:
            return None
        try:
            return self.fichiers[n]
        except IndexError:
            return None
</pre>
<p>La méthode <code class="methodname">on_iter_parent</code>() renvoie une référence de 
ligne à la ligne parent de la ligne indiquée par <em class="parameter"><code>refligne</code></em>. 
Si <em class="parameter"><code>refligne</code></em> pointe sur une ligne du niveau supérieur, on 
renvoie <code class="literal">None</code>. Dans l'exemple, <code class="literal">None</code> est 
toujours renvoyé en supposant que <em class="parameter"><code>refligne</code></em> doit pointer 
sur une ligne du niveau supérieur :
</p>
<pre class="programlisting">
    def on_iter_parent(child):
        return None
</pre>
<p>Ces exemples sont assemblés dans le programme 
<a href="exemples/listefichiers-gtm.py" target="_top">listefichiers-gtm.py</a>. La 
<a href="sec-GenericTreeModel.html#listefichiers-gtmfig" title="Figure 14.11. Exemple de TreeModel générique">Figure 14.11, « Exemple de TreeModel générique »</a> montre le résultat
</p>
<div class="figure">
<a name="listefichiers-gtmfig"></a><p class="title"><b>Figure 14.11. Exemple de TreeModel générique</b></p>
<div class="mediaobject" align="center"><img src="figures/listefichiers-gtm.png" align="middle" alt="Exemple de TreeModel générique."></div>
</div>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-AddRemoveGenericTreeModelRows"></a>14.11.3. Ajouter et supprimer des lignes</h3></div></div></div>
<p>Le programme <a href="exemples/listefichiers-gtm.py" target="_top">listefichiers-gtm.py</a> calcule la liste 
des noms de fichier lorsqu'il crée une instance de <code class="classname">FileListModel</code>. 
Si l'on souhaite vérifier réguliérement la création de nouveaux fichiers et ajouter ou 
retiter des fichiers du modèle, on peut soit créer un nouveau 
<code class="classname">FileListModel</code> pour le même répertoire, soit ajouter une méthode 
pour ajouter ou retirer des lignes dans le modèle. Selon le type de modèle créé, il 
peut être nécessaire d'ajouter une méthode semblable à celles des modèles de 
<code class="classname">TreeStore</code> et de <code class="classname">ListStore</code> :
</p>
<div class="itemizedlist"><ul type="disc">
<li>
<code class="methodname">insert</code>()</li>
<li>
<code class="methodname">insert_before</code>()</li>
<li>
<code class="methodname">insert_after</code>()</li>
<li>
<code class="methodname">prepend</code>()</li>
<li>
<code class="methodname">append</code>()</li>
<li>
<code class="methodname">remove</code>()</li>
<li>
<code class="methodname">clear</code>()</li>
</ul></div>
<p>Il n'est, bien sûr, pas nécessaire d'utiliser toutes ou même 
une seule de ces méthodes. On peut créer ses propres méthodes plus adaptées 
à son modèle.
</p>
<p>En utilisant le programme exemple prédécent pour montrer l'ajout de 
méthodes pour supprimer ou ajouter des fichiers, voici comment on implémente 
les méthodes 
</p>
<code class="methodsynopsis">    def <span class="methodname">remove</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>iter</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">add</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>filename</code></strong></span></span>)</code><br><p>La méthode <code class="methodname">remove</code>() retire le fichier indiqué par le 
paramétre <em class="parameter"><code>iter</code></em>. Outre retirer la ligne du modèle, la 
méthode efface aussi le fichier du répertoire. Évidemment, si l'utilisateur 
n'a pas les droits de suppression du ficher, la ligne n'est pas supprimée 
non plus. Par exemple :
</p>
<pre class="programlisting">
    def remove(self, iter):
        path = self.get_path(iter)
        pathname = self.get_pathname(path)
        try:
            if os.path.exists(pathname):
                os.remove(pathname)
            del self.files[path[0]]
            self.row_deleted(path)
        except OSError:
            pass
        return
</pre>
<p>La méthode transmet un <code class="classname">TreeIter</code> qu'il faut 
transformer en un chemin à utiliser pour récupérer le chemin du fichier par 
la méthode <code class="methodname">get_pathname</code>(). Il est possible que le 
fichier ait déjà été supprimé, il faut donc tester son existence avant de 
le supprimer. Si une exception OSError intervient pendant la suppression 
du fichier, c'est probablement parce que le fichier est dans un répertoire 
où l'utilisateur n'a pas suffisamment de droits. Finalement, le fichier 
est supprimé et le signal "row-deleted" est émis par la méthode 
<code class="methodname">rows_deleted</code>(). Le signal  "file-deleted" indique 
aux <code class="classname">TreeView</code> utilisant le modèle que ce modèle a changé, 
ainsi ils peuvent mettre à jour leur état interne et afficher le modèle 
modifié.
</p>
<p>La méthode <code class="methodname">add</code>() impose de créer un fichier dans le 
répertoire courant avec le nom donné. Si le fichier est créé, son nom est 
ajouté  à la liste des fichiers du modèle. Par exemple :
</p>
<pre class="programlisting">
    def add(self, filename):
        pathname = os.path.join(self.dirname, filename)
        if os.path.exists(pathname):
            return
        try:
            fd = file(pathname, 'w')
            fd.close()
            self.dir_ctime = os.stat(self.dirname).st_ctime
            files = self.files[1:] + [filename]
            files.sort()
            self.files = ['..'] + files
            path = (self.files.index(filename),)
            iter = self.get_iter(path)
            self.row_inserted(path, iter)
        except OSError:
            pass
        return
</pre>
<p>Cet exemple simple s'assure que le fichier n'existe pas déjà, puis tente 
d'ouvrir le fichier en écriture. Si cela réussit, le fichier est refermé 
et son nom inséré dans la liste de fichiers. Le chemin et le 
<code class="classname">TreeIter</code> de la ligne du fichier ajouté sont 
récupérés pour être utilisés dans la methode 
<code class="methodname">row_inserted</code>() qui émet le signal 
"row-inserted". Ce signal "row-inserted" sert à indiquer aux 
<code class="classname">TreeView</code> utilisant le modèle qu'ils doivent 
mettre à jour leur état et rafraîchir leur affichage.
</p>
<p>Les autres méthodes mentionnées précèdemment (par exemple 
<code class="methodname">append</code> et <code class="methodname">prepend</code>) n'ont 
pas de signification pour cet exemple puisque le modèle sa liste de fichiers 
triée.
</p>
<p>D'autres méthodes peuvent être utiles à utiliser dans un 
<code class="classname">TreeModel</code> découlant du 
<code class="classname">GenericTreeModel</code> :
</p>
<div class="itemizedlist"><ul type="disc">
<li>
<code class="methodname">set_value</code>()</li>
<li>
<code class="methodname">reorder</code>()</li>
<li>
<code class="methodname">swap</code>()</li>
<li>
<code class="methodname">move_after</code>()</li>
<li>
<code class="methodname">move_before</code>()</li>
</ul></div>
<p>L'implémentation de ces méthodes est similaire à celle des méthodes 
précédentes. Il faut synchroniser le modèle et l'état externe, et ensuite indiquer 
aux <code class="classname">TreeView</code> que le modèle a changé. Les méthodes suivantes 
sont utilisées pour indiquer aux <code class="classname">TreeView</code> les 
changement du modèle en envoyant le signal approprié :
</p>
<code class="methodsynopsis">    def <span class="methodname">row_changed</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>path</code></strong></span></span>, <span class="methodparam"><span class="parameter"><strong class="parameter"><code>iter</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">row_inserted</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>path</code></strong></span></span>, <span class="methodparam"><span class="parameter"><strong class="parameter"><code>iter</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">row_has_child_toggled</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>path</code></strong></span></span>, <span class="methodparam"><span class="parameter"><strong class="parameter"><code>iter</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">row_deleted</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>path</code></strong></span></span>)</code><br><code class="methodsynopsis">    def <span class="methodname">rows_reordered</span>(<span class="methodparam"><span class="parameter"><strong class="parameter"><code>path</code></strong></span></span>, <span class="methodparam"><span class="parameter"><strong class="parameter"><code>iter</code></strong></span></span>, <span class="methodparam"><span class="parameter"><strong class="parameter"><code>new_order</code></strong></span></span>)</code><p></p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-GenericTreeModelMemoryManagement"></a>14.11.4. Gestion de la mémoire</h3></div></div></div>
<p>L'un des problèmes avec le <code class="classname">GenericTreeModel</code> est 
que le <code class="classname">TreeIter</code> contient une référence à un 
objet Python venent du modèle personnalisé. Puisque le 
<code class="classname">TreeIter</code> peut être crée et initialisé dans un 
module en C et être présent dans la pile, il n'est pas possible de 
connaître le moment où le <code class="classname">TreeIter</code> est détruit 
et la référence à l'objet Python n'est plus d'utilité. Donc l'objet 
Python référencé dans un  <code class="classname">TreeIter</code> voit par défaut 
son cimpteur incrémenté, mais il n'est pas décrémenté lorque le 
<code class="classname">TreeIter</code> est détruit. Ceci garantit que l'objet 
Python ne peut être détruit quand il est utilisé par un 
<code class="classname">TreeIter</code> et produire éventuellement une erreur 
de segmentation. Malheureusement les comptes de référence supplémentaires 
font que, au mieux l'objet Python aura un compte de référence excessif et, 
au pire, il ne sera jamais libéré même lorsque il n'est pas utilisé. 
Le dernier cas cause des fuites de mémoire et le premier, des fuites de 
références.

</p>
<p>Pour parer à la situation où le <code class="classname">TreeModel</code> personnalisé 
maintient une référence à l'objet Python jusqu'à ce qu'il ne soit plus disponible 
(le <code class="classname">TreeIter</code> est invalide car le modèle a changé) et il 
n'y a pas besoin de relacher les références, le <code class="classname">GenericTreeModel</code> 
possède une propriété "leak-references". Par défaut, "leak-references" vaut 
<code class="literal">TRUE</code> pour indiquer que le <code class="classname">GenericTreeModel</code> 
relachera les références. Si "leak-references" vaut <code class="literal">FALSE</code>, le 
compteur de références de l'objet Python ne sera pas incrémenté quand il sera référencé 
dans un <code class="classname">TreeIter</code>. Ce qui signifie que le le 
<code class="classname">TreeModel</code> personnalisé doit conserver une référence 
à tous les objets Python utilisés dans un <code class="classname">TreeIter</code> jusqu'à 
la destruction du modèle. Malheureusement, même ceci ne protège pas d'un mauvais 
code qui tente d'utiliser un <code class="classname">TreeIter</code> sauvegardé dans un 
<code class="classname">GenericTreeModel</code> différent. Pour se protéger contre ce cas de 
figure, l'application doit conserver une référence à tous les objets Python 
référencés dans un <code class="classname">TreeIter</code> pour toutes les instances du 
<code class="classname">GenericTreeModel</code>. Naturellement, ceci a le le même effet 
qu'une fuite de références.
</p>
<p>Avec PyGTK 2.4 et ultérieurs, les méthodes <code class="methodname">invalidate_iters</code>() 
et <code class="methodname">iter_is_valid</code>() sont disponibles comme aide à la 
gestion des <code class="classname">TreeIter</code> et des références des objets Python :
</p>
<pre class="programlisting">
  generictreemodel.invalidate_iters()

  result = generictreemodel.iter_is_valid(<strong class="parameter"><code>iter</code></strong>)
</pre>
<p>Ceci est particulièrement utile lorsque la propriété "leak-references" vaut 
<code class="literal">FALSE</code>. Les modèles d'arbre dérivés du 
<code class="classname">GenericTreeModel</code> sont protégés des problèmes de 
<code class="classname">TreeIter</code> périmés car la validité des iters est automatiquement 
vérifiée avec le modèle arbre.
</p>
<p>Si un modèle d'arbre personnalisé ne gère pas les iters persistants (par exemple, 
<code class="literal">gtk.TREE_MODEL_ITERS_PERSIST</code> n'est pas établi dans le retour de 
la méthode <code class="methodname">TreeModel.get_flags</code>(), il est possible d'appeler 
la methode <code class="methodname">invalidate_iters</code>() pour annuler tous les 
<code class="classname">TreeIter</code> en cours quand le modèle est modifié (après insertion 
d'une nouvelle ligne par ex.). Le modèle d'arbre peut aussi utiliser n'importe quel objet 
Python qui a été référencé par un <code class="classname">TreeIter</code> après l'appel à 
la méthode <code class="methodname">invalidate_iters</code>().
</p>
<p>Les applications peuvent utiliser la méthode <code class="methodname">iter_is_valid</code>() 
pour déterminer si un <code class="classname">TreeIter</code> est encore valide pour le 
modèle d'arbre personnalisé.
</p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-OtherInterfaces"></a>14.11.5. Autres interfaces</h3></div></div></div>
<p>Les modèles <code class="classname">ListStore</code> et <code class="classname">TreeStore</code> 
comprennent outre l'interface <code class="classname">TreeModel</code>, les interfaces 
<code class="classname">TreeSortable</code>, <code class="classname">TreeDragSource</code> et 
<code class="classname">TreeDragDest</code>. Le  <code class="classname">GenericTreeModel</code> 
ne comprend que l'interface <code class="classname">TreeModel</code>. Je pense que c'est 
à cause de la référence directe au modèle dans le langage C par les modèles 
<code class="classname">TreeView</code>, <code class="classname">TreeModelSort</code> et 
<code class="classname">TreeModelFilter</code>. Créer et utiliser un <code class="classname">TreeIter</code> 
exige un code collant au C pour l'interface avec le modèle d'arbre personnalisé Python 
qui contient les données. Ce code collant est fourni par le <code class="classname">GenericTreeModel</code> 
et il semble qu'il n'y a pas d'alternative purement Python de réaliser ceci car le 
<code class="classname">TreeView</code> et les autres modèles appellent les fonctions du 
GtkTreeModel en C en passant leur référence au modèle d'arbre personnalisé.
</p>
<p>L'interface <code class="classname">TreeSortable</code> nécessite aussi un code collant 
au C pour agir sur le mécanisme de tri par défaut du <code class="classname">TreeViewColumn</code> 
ainsi qu'il est expliqué dans la <a href="sec-TreeModelInterface.html#sec-SortingTreeModelRows" title="14.2.9. Ordonner les lignes d'un TreeModel">Section 14.2.9, « Ordonner les lignes d'un TreeModel »</a>. 
Cependant un modèle personnalisé doit réaliser ses propres tris et une application 
doit gérer l'utilisation des critéres de tri en prenant en compte les clics sur 
les en-têtes des <code class="classname">TreeViewColumn</code> et en appelant les méthodes 
de tri du modèle d'arbre personnalisé. Le modèle effectue la mise à jour du 
<code class="classname">TreeView</code> en émettant le signal "rows-reordered" grace à 
la méthode <code class="methodname">rows_reordered</code>() du <code class="classname">TreeModel</code>. 
Ainsi le <code class="classname">GenericTreeModel</code> ne nécessite probablement pas 
d'implémenter l'interface <code class="classname">TreeSortable</code>.
</p>
<p>Pareillement, le <code class="classname">GenericTreeModel</code> n'a pas besoin d'
implémenter les interfaces <code class="classname">TreeDragSource</code> et 
<code class="classname">TreeDragDest</code> puisque le modèle d'arbre personnalisé 
peut effectuer ses propres interfaces de glisser-déposer et l'application 
peut gérer les signaux <code class="classname">TreeView</code> appropriés et faire 
appel aux méthodes du modèle d'arbre personnalisé tant que nécessaire.
</p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-ApplyingGenericTreeModel"></a>14.11.6. Utilisation du GenericTreeModel</h3></div></div></div>
<p>Je crois que le <code class="classname">GenericTreeModel</code> ne devrait être 
utilisé qu'en dernier ressort. Les objets standard du <code class="classname">TreeView</code> 
comprennent des mécanismes puissants qui devraient être suffisants pour la 
plupart des applications. Sans doute, il existe des applications qui peuvent 
avoir besoin du <code class="classname">GenericTreeModel</code> mais il faudrait d'abord 
essayer d'utiliser ce qui suit : 
</p>
<table border="0" width="100%" bgcolor="#FFECCE">
<col align="left" valign="top" width="0*">
<tbody>
<tr>
<td>
<span class="term">Cell Data Functions</span></td>
<td><p>Comme il est montré dans la <a href="sec-CellRenderers.html#sec-CellDataFunction" title="14.4.5. Fonction d'affichage des données cellulaires">Section 14.4.5, « Fonction d'affichage des données cellulaires »</a>, les 
fonctions de données des cellules peuvent être utilisées pour modifier et 
même produire les données pour un affichage d'une colonne du 
<code class="classname">TreeView</code>. On peut créer autant d'affichages de colonnes 
avec des données générées que l'on souhaite. Cela donne beaucoup de contrôle 
de la présentation de données d'une source de données sous-jacente.
</p></td>
</tr>
<tr>
<td>
<span class="term">TreeModelFilter</span></td>
<td><p>En PyGTK 2.4, le <code class="classname">TreeModelFilter</code>, comme indiqué dans la 
<a href="sec-TreeModelSortAndTreeModelFilter.html#sec-TreeModelFilter" title="14.10.2. Le TreeModelFilter">Section 14.10.2, « Le TreeModelFilter »</a>, permet un fort contrôle sur 
l'affichage des colonnes et lignes d'un <code class="classname">TreeModel</code> 
enfant, y compris afficher seulement les lignes filles d'une ligne. 
Les colonnes de données peuvent être produite d'une façon semblable à 
l'utilisation des fonctions de données en cellule ; ici le modèle est 
un <code class="classname">TreeModel</code> avec un nombre et un type de colonnes 
indiqués alors qu'une fonction de données de cellule laisse les colonnes modèles 
inchangées et modifie juste l'affichage dans un <code class="classname">TreeView</code>.
</p></td>
</tr>
</tbody>
</table>
<p>Si un <code class="classname">GenericTreeModel</code> doit être utilisé, il faut 
veiller à : 
</p>
<div class="itemizedlist"><ul type="disc">
<li>l'interface complète du <code class="classname">TreeModel</code> doit 
être créée et être en mesure de fonctionner comme indiqué. I y a des finesses 
qui peuvent induire des erreurs. Par opposition, le <code class="classname">TreeModel</code> 
standard a été complètement testé.
</li>
<li>gérer les références des objets Python utilisés par un 
<code class="classname">TreeIter</code> peut se révéler difficile, particulièrement 
pour des programmes longs avec beaucoup d'affichages variés.
</li>
<li>il faut créer un interface pour ajouter, supprimer ou modifier 
le contenu des lignes. Le lien d'un TreeIter aux objets de Python et aux rangées 
modèles dans cette interface n'est pas trés élégant.
</li>
<li>le développement d'interfaces de glisser-déposer et de tri demande 
un effort important, l'application doit trés probablement participer à ce que ces 
interfaces soient entièrement fonctionnelles.
</li>
</ul></div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="sec-TreeModelSortAndTreeModelFilter.html">Préc.</a> </td>
<td width="20%" align="center"><a accesskey="u" href="ch-TreeViewWidget.html">Chapitre parent</a></td>
<td width="40%" align="right"> <a accesskey="n" href="sec-GenericCellRenderer.html">Suiv.</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">14.10. TreeModelSort et TreeModelFilter </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Table des matières</a></td>
<td width="40%" align="right" valign="top"> 14.12. The Generic CellRenderer</td>
</tr>
</table>
</div>
</body>
</html>
