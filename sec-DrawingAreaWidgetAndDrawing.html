<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
<title>24.3. Le widget zone de dessin (DrawingArea) et le dessin</title>
<link rel="stylesheet" href="pygtktutfr.css">
<link rel="start" href="index.html" title="Tutoriel PyGTK 2.0">
<link rel="up" href="ch-Scribble.html" title="Chapitre 24. Scribble, Un programme simple de dessin">
<link rel="prev" href="sec-EventHandling.html" title="24.2. Gestion des évènements">
<link rel="next" href="ch-TipsForWritingPyGTKApplications.html" title="Chapitre 25. Tips For Writing PyGTK Applications">
<meta name="keywords" content="python,pygtk,tutoriel,traduction">
<link rel="home" href="index.html" title="Table des matières">
</head>
<body>
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">24.3. Le widget zone de dessin (DrawingArea) et le dessin</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="sec-EventHandling.html">Préc.</a> </td>
<th width="60%" align="center">Chapitre 24. Scribble, Un programme simple de dessin</th>
<!--
<td width="20%" align="right"> <a accesskey="n" href="ch-TipsForWritingPyGTKApplications.html">Suiv.</a>
-->
<td width="20%" align="right">Suiv.</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1" lang="fr">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="sec-DrawingAreaWidgetAndDrawing"></a>24.3. Le widget zone de dessin (DrawingArea) et le dessin</h2></div></div></div>
<p>Passons au processus de dessin sur l'écran. Le widget que l'on
utilise pour ceci est le widget <code class="classname">DrawingArea</code> (voir le
<a href="ch-DrawingArea.html" title="Chapitre 12. La zone de dessin (Drawing Area)">Chapitre 12, <i>La zone de dessin (Drawing Area)</i></a>). Un tel widget est essentiellement une
fenêtre X et rien de plus. Il s'agit d'une toile vide sur laquelle nous pouvons
dessiner ce que nous voulons. On créé ce widget par l'appel à :</p>
<pre class="programlisting">
  darea = gtk.DrawingArea()
</pre>
<p>On peut lui donner Une taille par défaut par l'appel :</p>
<pre class="programlisting">
  darea.set_size_request(<strong class="parameter"><code>largeur</code></strong>, <strong class="parameter"><code>hauteur</code></strong>)
</pre>
<p>Cette taille par défaut peu être surchargée, comme pour tous les widgets,
en appelant la méthode <code class="methodname">set_size_request</code>() et celle-ci,
à son tour, peut être surchargée si l'utilisateur modifie manuellement la taille
de la fenêtre contenant la zone de dessin.</p>
<p>Il faut noter que lorsque l'on crée un widget
<code class="classname">DrawingArea</code>, on est complètement responsable du dessin
du contenu. Si la fenêtre est cachée puis redécouverte, on reçoit un événement
d'exposition et on doit redessiner ce qui avait été caché auparavant.</p>
<p>Devoir se rappeler tout ce qui a été dessiné à l'écran pour pouvoir
correctement le redessiner peut s'avérer, et c'est un euphémisme, pénible. De plus,
cela peut être visible si des portions de la fenêtre sont effacées puis redessinées
étape par étape. La solution à ce problème est d'utiliser un pixmap d'arrière-plan
hors écran. Au lieu de dessiner directement sur l'écran, on dessine sur une image
stockée dans la mémoire du serveur et non affichée, puis, lorsque l'image change ou
lorsque de nouvelles parties de l'image sont affichées, on copie les parties
correspndantes sur l'écran.</p>
<p>Pour créer un pixmap hors écran, on appelle la fonction :</p>
<pre class="programlisting">
  pixmap = gtk.gdk.Pixmap(<strong class="parameter"><code>fenetre</code></strong>, <strong class="parameter"><code>largeur</code></strong>, <strong class="parameter"><code>hauteur</code></strong>, <strong class="parameter"><code>profondeur</code></strong>=-1)
</pre>
<p>Le paramètre <em class="parameter"><code>fenetre</code></em> désigne une fenêtre
<code class="classname">gtk.gdk.Window</code> d'où ce pixmap tire certaines de ses
propriétés. Les paramètres  <em class="parameter"><code>largeur</code></em> et
<em class="parameter"><code>hauteur</code></em> précisent la taille du pixmap, <em class="parameter"><code>profondeur</code></em>
précise la profondeur de couleur (c'est-à-dire le nombre de bits par pixel)
de la nouvelle fenêtre. Si cette <em class="parameter"><code>profondeur</code></em> vaut -1 ou
n'est pas indiquée, elle correspondra à celle de <em class="parameter"><code>fenetre</code></em>.</p>
<p>On crée le pixmap dans notre gestionnaire "configure_event".
Cet événement est généré à chaque fois que la fenêtre change de taille,
y compris lors de sa création initiale.</p>
<pre class="programlisting">
    32   # Création d'un nouveau pixmap d'arrière-plan de la taille voulue
    33   def configure_event(widget, event):
    34       global pixmap
    35
    36       x, y, largeur, hauteur = widget.get_allocation()
    37       pixmap = gtk.gdk.Pixmap(widget.window, largeur, hauteur)
    38       pixmap.draw_rectangle(widget.get_style().white_gc,
    39                             True, 0, 0, largeur, hauteur)
    40
    41       return True
 </pre>
<p>L'appel à <code class="methodname">draw_rectangle</code>() initialise le pixmap
à blanc. Nous en dirons plus tout à l'heure.</p>
<p>Le gestionnaire d'événement d'exposition copie alors simplement la
partie utile du pixmap sur la zone de dessin (widget) en utilisant la
méthode <code class="methodname">draw_pixmap</code>(). On détermine la zone
à redessiner en utilisant l'attribut <em class="parameter"><code>event.area</code></em> de
l'événement d'exposition) :</p>
<pre class="programlisting">
    43   # Redessine l'écran à partir du pixmap d'arrière-plan
    44   def expose_event(widget, event):
    45       x , y, largeur, hauteur = event.area
    46       widget.window.draw_drawable(widget.get_style().fg_gc[gtk.STATE_NORMAL],
    47                                   pixmap, x, y, x, y, largeur, hauteur)
    48       return False
</pre>
<p>On a vu comment garder l'écran à jour avec notre pixmap, mais
comment dessine-t-on réellement ce que l'on veut dans le pixmap ? Il existe
un grand nombre d'appels dans PyGTK pour dessiner sur des dessinables. Un
dessinable est simplement quelque chose sur lequel on peut dessiner. Cela peut
être une fenêtre, un pixmap, ou un bitmap (une image en noir et blanc). On a déjà
vu plus haut deux de ces appels, <code class="methodname">draw_rectangle</code>() et
<code class="methodname">draw_pixmap</code>(). En voici La liste complète :</p>
<pre class="programlisting">
  drawable.draw_point(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>x</code></strong>, <strong class="parameter"><code>y</code></strong>)

  drawable.draw_line(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>x1</code></strong>, <strong class="parameter"><code>y1</code></strong>, <strong class="parameter"><code>x2</code></strong>, <strong class="parameter"><code>y2</code></strong>)

  drawable.draw_rectangle(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>fill</code></strong>, <strong class="parameter"><code>x</code></strong>, <strong class="parameter"><code>y</code></strong>, <strong class="parameter"><code>width</code></strong>, <strong class="parameter"><code>height</code></strong>)

  drawable.draw_arc(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>fill</code></strong>, <strong class="parameter"><code>x</code></strong>, <strong class="parameter"><code>y</code></strong>, <strong class="parameter"><code>width</code></strong>, <strong class="parameter"><code>height</code></strong>, <strong class="parameter"><code>angle1</code></strong>, <strong class="parameter"><code>angle2</code></strong>)

  drawable.draw_polygon(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>fill</code></strong>, <strong class="parameter"><code>points</code></strong>)

  drawable.draw_drawable(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>src</code></strong>, <strong class="parameter"><code>xsrc</code></strong>, <strong class="parameter"><code>ysrc</code></strong>, <strong class="parameter"><code>xdest</code></strong>, <strong class="parameter"><code>ydest</code></strong>, <strong class="parameter"><code>width</code></strong>, <strong class="parameter"><code>height</code></strong>)

  drawable.draw_points(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>points</code></strong>)

  drawable.draw_lines(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>points</code></strong>)

  drawable.draw_segments(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>segments</code></strong>)

  drawable.draw_rgb_image(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>x</code></strong>, <strong class="parameter"><code>y</code></strong>, <strong class="parameter"><code>width</code></strong>, <strong class="parameter"><code>height</code></strong>, <strong class="parameter"><code>dither</code></strong>, <strong class="parameter"><code>buffer</code></strong>, <strong class="parameter"><code>rowstride</code></strong>)

  drawable.draw_rgb_32_image(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>x</code></strong>, <strong class="parameter"><code>y</code></strong>, <strong class="parameter"><code>width</code></strong>, <strong class="parameter"><code>height</code></strong>, <strong class="parameter"><code>dither</code></strong>, <strong class="parameter"><code>buffer</code></strong>, <strong class="parameter"><code>rowstride</code></strong>)

  drawable.draw_gray_image(<strong class="parameter"><code>gc</code></strong>, <strong class="parameter"><code>x</code></strong>, <strong class="parameter"><code>y</code></strong>, <strong class="parameter"><code>width</code></strong>, <strong class="parameter"><code>height</code></strong>, <strong class="parameter"><code>dither</code></strong>, <strong class="parameter"><code>buffer</code></strong>, <strong class="parameter"><code>rowstride</code></strong>)
</pre>
<p>Les méthodes des zones de dessin sont identiques à celles des
dessinables, ainsi on peut se reporter aux méthodes décrites dans la
<a href="sec-DrawingMethods.html" title="12.2. Les méthodes pour dessiner">Section 12.2, « Les méthodes pour dessiner »</a> pour plus de détails sur celles-ci.
Toutes ces méthodes partagent les mêmes premiers arguments, le premier étant
le contexte graphique (<em class="parameter"><code>gc</code></em>).</p>
<p>Un contexte graphique encapsule l'information sur des éléments
comme la couleur de premier et d'arrière plan et la largeur de ligne. PyGTK
possède un ensemble complet de fonctions pour créer et manipuler les contextes
graphiques, mais, pour faire simple, nous n'utiliserons que les contextes graphiques
prédéfinis. Reportez-vous à la <a href="ch-DrawingArea.html#sec-GraphicsContext" title="12.1. Le contexte graphique">Section 12.1, « Le contexte graphique »</a> pour
plus d'informations sur les contextes graphiques. Chaque widget posséde un style
associé (qui peut être modifié dans un fichier <code class="filename">gtkrc</code>, voir la
<a href="ch-GtkRcFiles.html" title="Chapitre 23. Les fichiers de style rc GTK">Chapitre 23, <i>Les fichiers de style rc GTK</i></a>. Celui-ci, entre autres choses, stocke plusieurs
contextes graphiques. Quelques exemples d'accès à ces contextes graphiques :
</p>
<pre class="programlisting">
  widget.get_style().white_gc

  widget.get_style().black_gc

  widget.get_style().fg_gc[STATE_NORMAL]

  widget.get_style().bg_gc[STATE_PRELIGHT]
</pre>
<p>Les champs <em class="parameter"><code>fg_gc</code></em>, <em class="parameter"><code>bg_gc</code></em>,
<em class="parameter"><code>dark_gc</code></em> et <em class="parameter"><code>light_gc</code></em> sont indexés par
un paramètre qui peut prendre les valeurs suivantes :</p>
<pre class="programlisting">
  STATE_NORMAL,
  STATE_ACTIVE,
  STATE_PRELIGHT,
  STATE_SELECTED,
  STATE_INSENSITIVE
</pre>
<p>Par exemple, pour <code class="literal">STATE_SELECTED</code>, la couleur de premier
plan par défaut est blanc, la couleur d'arrière plan par défaut est bleu foncé.</p>
<p>La fonction <code class="methodname">draw_brush</code>(), qui réalise le dessin
sur le pixmap est alors :</p>
<pre class="programlisting">
    50   # Dessine un rectangle sur l'écran
    51   def brosse_dessin(widget, x, y):
    52       rect = (int(x-5), int(y-5), 10, 10)
    53       pixmap.draw_rectangle(widget.get_style().black_gc, True,
    54                             rect[0], rect[1], rect[2], rect[3])
    55       widget.queue_draw_area(rect[0], rect[1], rect[2], rect[3])
</pre>
<p>Après avoir dessiné le rectangle représentant la brosse sur
      le pixmap, on appelle la fonction :</p>
<pre class="programlisting">
  widget.queue_draw_area(<strong class="parameter"><code>x</code></strong>, <strong class="parameter"><code>y</code></strong>, <strong class="parameter"><code>width</code></strong>, <strong class="parameter"><code>height</code></strong>)
</pre>
<p>... qui indique à X que cette zone nécessite d'être mise à jour.
X génèrera éventuellement un événement d'exposition (en combinant peut-être les
zones passés dans plusieurs appels à <code class="methodname">draw</code>()) ce qui
forcera le gestionnaire d'événement d'exposition à recopier les parties adéquates
à l'écran.</p>
<p>Nous avons maintenant couvert entièrement le programme de dessin,
sauf quelques détails banals comme la création de la fenêtre principale.</p>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="sec-EventHandling.html">Préc.</a> </td>
<td width="20%" align="center"><a accesskey="u" href="ch-Scribble.html">Chapitre parent</a></td>
<!--
<td width="40%" align="right"> <a accesskey="n" href="ch-TipsForWritingPyGTKApplications.html">Suiv.</a>
-->
<td width="40%" align="right">Suiv.</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">24.2. Gestion des évènements </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<!--
<td width="40%" align="right" valign="top"> Chapitre 25. Tips For Writing PyGTK Applications</td>
-->
<td width="40%" align="right"></a>
</tr>
</table>
</div>
</body>
</html>
