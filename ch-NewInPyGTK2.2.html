<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Chapitre 15. Nouveaux Widgets dans PyGTK 2.2</title>
<link rel="stylesheet" href="pygtktutfr.css" type="text/css">
<meta name="generator" content="Bluefish 1.0.5">
<meta name="keywords" content="python,pygtk,tutoriel,traduction,clipboard" />
<link rel="start" href="index.html" title="Tutoriel PyGTK 2.0">
<link rel="up" href="index.html" title="Tutoriel PyGTK 2.0">
<link rel="prev" href="sec-GenericCellRenderer.html" title="14.12. The Generic CellRenderer">
<link rel="next" href="ch-NewInPyGTK2.4.html" title="Chapitre 16. Nouveaux Widgets dans PyGTK 2.4">
</head>
<body>
<div class="localisation"> 
Vous êtes à peu près ici : 
<a href="../../index.html">Accueil</a>&nbsp;  &raquo;  &nbsp;
<a href="../pygtktut.php">tutoriel PyGTK</a>&nbsp; &raquo; &nbsp;
 <a href="index.html">PyGTK : sommaire</a>
</div> <!-- fin localisation --> 
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Chapitre 15. Nouveaux Widgets dans PyGTK 2.2</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="sec-GenericCellRenderer.html">Préc.</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="ch-NewInPyGTK2.4.html">Suiv.</a>
</tr>
</table>
<hr>
</div>
<div class="chapter" lang="fr">
<div class="titlepage"><div><div><h2 class="title">
<a name="ch-NewInPyGTK2.2"></a>Chapitre 15. Nouveaux Widgets dans PyGTK 2.2</h2>
</div></div></div>
<div class="toc">
<p><b>Table des matières</b></p>
<dl>
<dt><span class="sect1"><a href="ch-NewInPyGTK2.2.html#sec-Clipboards">15.1. Les Clipboards</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="ch-NewInPyGTK2.2.html#sec-CreatingClipboard">15.1.1. Créer un clipboard</a></span></dt>
<dt><span class="sect2"><a href="ch-NewInPyGTK2.2.html#sec-UsingClipboards">15.1.2. Utiliser les Clipboard avec les Entry, Spinbutton et TextView</a></span></dt>
<dt><span class="sect2"><a href="ch-NewInPyGTK2.2.html#sec-SettingClipboardData">15.1.3. Affecter des données à un Clipboard</a></span></dt>
<dt><span class="sect2"><a href="ch-NewInPyGTK2.2.html#sec-RetrievingClipboardContents">15.1.4. Récupérer le contenu du Clipboard</a></span></dt>
<dt><span class="sect2"><a href="ch-NewInPyGTK2.2.html#sec-ClipboardExample">15.1.5. Exemple de Clipboard</a></span></dt>
</dl></dd>
</dl>
</div>
<p>L'objet <code class="classname">Clipboard</code> a été ajouté en PyGTK 2.2. Le 
<code class="classname">GtkClipboard</code> était disponible en GTK+ 2.0 mais 
n'était pas utilisé par PyGTK 2.0 car il n'était pas un 
<code class="classname">GObject</code> complet. Quelques nouveaux objets ont été ajoutés 
au module gtk.gdk de PyGTK 2.2 mais ils ne seront pas décrits dans ce tutoriel. 
Lisez le <a href="http://www.pygtk.org/pygtk2reference/index.html" target="_top">PyGTK 2
Reference Manual</a> pour obtenir des informations sur les objets 
<code class="classname">gtk.gdk.Display</code>, 
<code class="classname">gtk.gdk.DisplayManager</code> et 
<code class="classname">gtk.gdk.Screen</code>
</p>
<div class="sect1" lang="fr">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="sec-Clipboards"></a>15.1. Les Clipboards</h2></div></div></div>
<p>Un <code class="classname">Clipboard</code> fournit une zone de stockage pour partager 
des données entre processus ou entre différents widgets du même 
processus. Chaque <code class="classname">Clipboard</code> est identifié par un nom 
encodé en tant que <code class="classname">gdk.Atom</code>. On peut utiliser n'importe 
quel nom souhaité pour identifier un <code class="classname">Clipboard</code>, celui-ci 
sera créé s'il n'existe pas. Si on souhaite partager un <code class="classname">Clipboard</code> 
avec d'autres processus, chaque processus doit connaître le nom du 
<code class="classname">Clipboard</code>.
</p>
<p>Les <code class="classname">Clipboard</code> sont construits à partir des 
<code class="classname">SelectionData</code> et des interfaces de sélection. Le 
<code class="classname">Clipboard</code> par défaut utilisé par les widgets
<code class="classname">TextView</code>, <code class="classname">Label</code> et
<code class="classname">Entry</code> se nomme "CLIPBOARD". Les autres clipboards 
courants sont  "PRIMARY" et "SECONDARY", ce qui correspond aux sélections 
primaires et secondaires (inconnues de Win32). Elles peuvent aussi être 
désignées par les objets <code class="classname">gtk.gdk.Atom</code> :
<code class="literal">gtk.gdk.SELECTION_CLIPBOARD</code>,
<code class="literal">gtk.gdk.SELECTION_PRIMARY</code> et
<code class="literal">gtk.gdk.SELECTION_SECONDARY</code>.  Se reporter à la  
<a href="http://www.pygtk.org/pygtk2reference/class-gdkatom.html" target="_top">
 documentation de référence gtk.gdk.Atom</a> pour plus d'information.
</p>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-CreatingClipboard"></a>15.1.1. Créer un clipboard</h3></div></div></div>
<p>Un <code class="classname">Clipboard</code> est créé par le 
constructeur :</p>
<pre class="programlisting">
  presse_papier = gtk.Clipboard(<strong class="parameter"><code>display</code></strong>, <strong class="parameter"><code>selection</code></strong>)
</pre>
<p>...où <em class="parameter"><code>display</code></em> est le <code class="classname">gtk.gdk.Display</code> 
associé avec le <code class="classname">Clipboard</code> désigné par le paramètre 
<em class="parameter"><code>selection</code></em>. 
La fonction suivante crée un <code class="classname">Clipboard</code> en utilisant le 
<code class="classname">gtk.gdk.Display</code> par défaut :

</p>
<pre class="programlisting">
  presse_papier = gtk.clipboard_get(<strong class="parameter"><code>selection</code></strong>)
</pre>
<p>Enfin, un <code class="classname">Clipboard</code> peut aussi être créé par la 
méthode <code class="classname">Widget</code> :
</p>
<pre class="programlisting">
  presse_papier = widget.get_clipboard(<strong class="parameter"><code>selection</code></strong>)
</pre>
<p>Le widget doit être "réalisé" et appartenir à la hiérarchie de la fenêtre 
racine.
</p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-UsingClipboards"></a>15.1.2. Utiliser les Clipboard avec les Entry, Spinbutton et TextView</h3></div></div></div>
<p>Les widgets <code class="classname">Entry</code>, <code class="classname">SpinButton</code> 
et <code class="classname">TextView</code> possèdent des menus contextuels qui offrent la 
possibilité de couper ou copier le texte sélectionné et de le coller à partir 
du presse-papier "CLIPBOARD". De plus, des liens sont établis 
 pour permettre des raccourcis clavier pour couper, copier et coller. 
Couper est activé par <span><strong class="keycap">Control</strong></span>+<span><strong class="keycap">X</strong></span> , 
copier par <span><strong class="keycap">Control</strong></span>+<span><strong class="keycap">C</strong></span> et 
coller par <span><strong class="keycap">Control</strong></span>+<span><strong class="keycap">V</strong></span>.
</p>
<p>Les widgets (<code class="classname">Entry</code> et 
<code class="classname">SpinButton</code>) mettent en oeuvre l'interface 
<code class="classname">Editable</code> qui possède les méthodes suivantes pour 
couper, copier et coller de et vers le "CLIPBOARD" clipboard :
</p>
<pre class="programlisting">
  editable.cut_clipboard()
  editable.copy_clipboard()
  editable.paste_clipboard()
</pre>
<p>Un <code class="classname">Label</code> sélectionnable (la propriété "selectable" 
vaut <code class="literal">TRUE</code>) permet aussi de copier le texte dans le 
presse-papier "CLIPBOARD"
</p>en utilisant un menu contextuel ou  le raccourci clavier 
<span><strong class="keycap">Control</strong></span>+<span><strong class="keycap">C</strong></span>.

        <p>Les <code class="classname">TextBuffer</code> ont des méthodes similaires bien qu'ils 
permettent aussi de préciser le presse-papier à utiliser :
</p>
<pre class="programlisting">
  textbuffer.copy_clipboard(<strong class="parameter"><code>clipboard</code></strong>)
</pre>
<p>Le texte sélectionné sera copié dans le <code class="classname">Clipboard</code> 
indiqué par <em class="parameter"><code>clipboard</code></em>.
</p>
<pre class="programlisting">
  textbuffer.cut_clipboard(<strong class="parameter"><code>clipboard</code></strong>, <strong class="parameter"><code>default_editable</code></strong>)
</pre>
<p>Le texte sélectionné sera copié dans <em class="parameter"><code>clipboard</code></em>. 
Si le paramètre <em class="parameter"><code>default_editable</code></em> vaut 
<code class="literal">TRUE</code>, le texte sélectionné sera aussi effacé du 
<code class="classname">TextBuffer</code>. Sinon, la methode 
<code class="methodname">cut_clipboard</code>() fonctionnera comme la méthode 
<code class="methodname">copy_clipboard</code>() .
</p>
<pre class="programlisting">
  textbuffer.paste_clipboard(<strong class="parameter"><code>clipboard</code></strong>, <strong class="parameter"><code>override_location</code></strong>, <strong class="parameter"><code>default_editable</code></strong>)
</pre>
<p>Si le paramètre <em class="parameter"><code>default_editable</code></em> vaut 
<code class="literal">TRUE</code>, 
le contenu de <em class="parameter"><code>clipboard</code></em> sera inséré dans le 
<code class="classname">TextBuffer</code> à l'endroit indiqué par le paramètre 
<em class="parameter"><code>override_location</code></em> du <code class="classname">TextIter</code>
</p>. Si <em class="parameter"><code>default_editable</code></em> vaut <code class="literal">FALSE</code>, 
la méthode <code class="methodname">paste_clipboard</code>() n'insèrera pas le 
contenu de <em class="parameter"><code>clipboard</code></em>. Si le paramètre 
<em class="parameter"><code>override_location</code></em> vaut <code class="literal">None</code>, le contenu de 
<em class="parameter"><code>clipboard</code></em> sera inséré à l'emplacement du curseur. 

        <p>Les <code class="classname">TextBuffer</code> possèdent aussi deux méthodes 
pour gérer un ensemble de <code class="classname">Clipboard</code> qui sont automatiquement 
affectés avec le contenu de la sélection en cours :
</p>
<pre class="programlisting">
  textbuffer.add_selection_clipboard(<strong class="parameter"><code>clipboard</code></strong>)
  textbuffer.remove_selection_clipboard(<strong class="parameter"><code>clipboard</code></strong>)
</pre>
<p>Quand un <code class="classname">TextBuffer</code> est ajouté à un 
<code class="classname">TextView</code>, le presse-papiers "PRIMARY" est automatiquement 
ajouté aux presse-papiers choisis. L'application peut ajouter d'autres presse-papiers, 
(par exemple le presse-papier "CLIPBOARD"). 
</p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-SettingClipboardData"></a>15.1.3. Affecter des données à un Clipboard</h3></div></div></div>
<p>Il est possible d'affecter des données au <code class="classname">Clipboard</code> 
par programme  en utilisant l'une de ces méthodes :
</p>
<pre class="programlisting">
  presse_papier.set_with_data(<strong class="parameter"><code>cibles</code></strong>, <strong class="parameter"><code>get_func</code></strong>, <strong class="parameter"><code>clear_func</code></strong>, <strong class="parameter"><code>donnees_utilisateur</code></strong>)

  presse_papier.set_text(<strong class="parameter"><code>text</code></strong>, <strong class="parameter"><code>len</code></strong>=-1)
</pre>
<p>La méthode <code class="methodname">set_with_data</code>() indique quelles cibles de 
données sélectionnées sont acceptées et fournit les fonctions
(<em class="parameter"><code>get_func</code></em> et <em class="parameter"><code>clear_func</code></em>) qui 
sont appelées quand les données sont appelées ou quand les données du presse-papiers 
sont  modifiées. Le paramètre <em class="parameter"><code>donnees_utilisateur</code></em> est transmis 
à  <em class="parameter"><code>get_func</code></em> où  à <em class="parameter"><code>clear_func</code></em> 
quand elles sont appelées. Le paramètre <em class="parameter"><code>cibles</code></em> est une 
liste de 3-tuples contenant :
</p>
<div class="itemizedlist"><ul type="disc">
<li>une chaîne représentant une cible acceptée 
            par le presse-papiers.</li>
<li>une valeur de drapeau utilisée pour le glisser/déposer - 
            on utilise 0.</li>
<li>un entier affecté à l'application qui est transmis comme paramètre 
            au gestionnaire de signal pour aider à identifier le type de cible.</li>
</ul></div>
<p>Les paramètres de <em class="parameter"><code>get_func</code></em> et de 
<em class="parameter"><code>clear_func</code></em> sont :
</p>
<pre class="programlisting">
  def get_func(presse_papier, donnees_selection, info, data):

  def clear_func(presse_papier, data):
</pre>
<p>...où le paramètre <em class="parameter"><code>presse_papier</code></em> est le 
        <code class="classname">Clipboard</code>, le paramètre <em class="parameter"><code>donnees_selection</code></em> 
        est un objet  <code class="classname">SelectionData</code> contenant les données, le paramètre 
<em class="parameter"><code>info</code></em>  est l'entier assigné à l'application, associé à une cible 
et le paramètre <em class="parameter"><code>data</code></em> représente les données utilisateur.
</p>
<p>La méthode <code class="methodname">set_text</code>() est une méthode commode 
qui utilise la méthode <code class="methodname">set_with_data</code>() pour 
placer les données texte dans un <code class="classname">Clipboard</code> avec pour 
cibles : "STRING", "TEXT", "COMPOUND_TEXT", et "UTF8_STRING". Elle utilise 
les fonctions internes get et clear pour gérer les données. Cette méthode 
est équivalente à :
</p>
<pre class="programlisting">
  def my_set_text(self, texte, len=-1):
      targets = [ ("STRING", 0, 0),
                  ("TEXT", 0, 1),
                  ("COMPOUND_TEXT", 0, 2),
                  ("UTF8_STRING", 0, 3) ]
      def text_get_func(presse_papier, donnees_selection, info, data):
          selection.set_text(data)
          return
      def text_clear_func(presse_papier, data):
          del data
          return
      self.set_with_data(cibles, text_get_func, text_clear_func, texte)
      return
</pre>
<p>Une fois les données placées dans le presse-papiers, elles demeurent disponibles 
jusqu'à la fermeture de l'application ou jusqu'à leur remplacement.
</p>
<p>Pour obtenir le comportement habituel du couper dans un presse-papiers, 
l'application doit supprimer le texte ou l'objet sélectionné après 
l'avoir recopié dans le presse-papiers.
</p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-RetrievingClipboardContents"></a>15.1.4. Récupérer le contenu du Clipboard</h3></div></div></div>
<p>Le contenu du <code class="classname">Clipboard</code> peut être récupéré 
avec la méthode suivante :
</p>
<pre class="programlisting">
  clipboard.request_contents(<strong class="parameter"><code>target</code></strong>, <strong class="parameter"><code>callback</code></strong>, <strong class="parameter"><code>user_data</code></strong>=None)
</pre>
<p>Les contenus indiqués par <em class="parameter"><code>target</code></em> sont récupérés de 
manière asynchrone dans la fonction indiquée par le paramètre 
<em class="parameter"><code>callback</code></em> qui est appelé avec <em class="parameter"><code>user_data</code></em>. 
le paramètre <em class="parameter"><code>callback</code></em> a la forme :
</p>
<pre class="programlisting">
  def callback(presse_papier, donnees_selection, data):
</pre>
<p>... où <em class="parameter"><code>donnees_selection</code></em> est un objet <code class="classname">SelectionData</code> 
conservant le contenu du <em class="parameter"><code>presse_papier</code></em>. <em class="parameter"><code>data</code></em> 
contient les <em class="parameter"><code>données utilisateur</code></em>. La méthode <code class="methodname">request_contents</code>() 
est la façon la plus commune de récupérer le contenu d'un <code class="classname">Clipboard</code>. 
La méthode suivante est commode pour retrouver le contenu texte d'un <code class="classname">Clipboard</code> :

</p>
<pre class="programlisting">
  clipboard.request_text(<strong class="parameter"><code>callback</code></strong>, <strong class="parameter"><code>user_data</code></strong>=None)
</pre>
<p>La chaîne texte est renvoyée à la fonction de rappel à la place d'un objet 
<code class="classname">Selectiondata</code>. Vous pouvez vérifier quelles cibles sont 
disponibles sur le  <code class="classname">Clipboard</code> en employant la méthode :
</p>
<pre class="programlisting">
  clipboard.request_targets(<strong class="parameter"><code>callback</code></strong>, <strong class="parameter"><code>user_data</code></strong>=None)
</pre>
<p>Les cibles sont retournées à la fonction de rappel comme un tuple d'objets 
<code class="classname">gtk.gdk.Atom</code>.
</p>
<p>Deux méthodes pratiques sont fournies pour renvoyer le contenu du 
<code class="classname">Clipboard</code> de manière synchrone :
</p>
<pre class="programlisting">
  donnees_selection = clipboard.wait_for_contents(cible)

  texte = clipboard.wait_for_text()
</pre>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-ClipboardExample"></a>15.1.5. Exemple de Clipboard</h3></div></div></div>
<p>Pour illustrer l'utilisation d'un <code class="classname">Clipboard</code>, le programme 
<a href="exemples/clipboard.py" target="_top">clipboard.py</a> récupère les éléments de texte 
qui sont coupés ou copiés vers le presse-papiers "CLIPBOARD" et sauvegarde les dix 
dernières entrées du presse-papiers. Il y a dix boutons qui permettent d'accéder 
au texte des entrées sauvegardées. Le texte du bouton affiche les seize premiers 
caractères du texte sauvé et les infobulles montrent les cibles que la zone de texte avait à l'origine. 
Quand on clique sur un bouton d'entrée, le texte sauvegardé associé s'inscrit 
dans la fenêtre de texte ; il est modifiable. Le bouton sous la fenêtre de texte sauvegarde 
le contenu actuel de la fenêtre dans le presse-papiers.
</p>
<p><a href="ch-NewInPyGTK2.2.html#clipboardfig" title="Figure 15.1. Exemple de Clipboard">Figure 15.1, « Exemple de Clipboard »</a> montre le programme <a href="exemples/clipboard.py" target="_top">clipboard.py</a> en action :</p>
<div class="figure">
<a name="clipboardfig"></a><p class="title"><b>Figure 15.1. Exemple de Clipboard</b></p>
<div class="mediaobject" align="center"><img src="figures/clipboard.png" align="middle" alt="Programme d'exemple de Clipboard"></div>
</div>
<p>Le programme d'exemple sonde le presse-papiers toutes les 1,5 secondes pour voir 
si le contenu a changé. Le programme peut être modifié pour dupliquer la totalité 
de contenu de cible et prendre le contrôle en employant la méthode 
<code class="methodname">set_with_data</code>(). Plus tard, quand un autre programme 
place du contenu dans le presse-papiers, le paramètre <em class="parameter"><code>clear_func</code></em> sera 
appelé , il pourra être utilisé pour recharger le contenu du presse-papiers et en
reprendre le contrôle .
</p>
</div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="sec-GenericCellRenderer.html">Préc.</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="ch-NewInPyGTK2.4.html">Suiv.</a>
</tr>
<tr>
<td width="40%" align="left" valign="top">14.12. The Generic CellRenderer </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Table des matières</a></td>
<td width="40%" align="right" valign="top"> Chapitre 16. Nouveaux Widgets dans PyGTK 2.4</td>
</tr>
</table>
</div>
<!-- phpmyvisites -->
<a href="http://st.free.fr/" title="phpMyVisites | Open source web analytics"
onclick="window.open(this.href);return(false);"><script type="text/javascript">
<!--
var a_vars = Array();
var pagename=document.title;

var phpmyvisitesSite = 17647;
var phpmyvisitesURL = "http://st.free.fr/phpmyvisites.php";
//-->
</script>
<script language="javascript" src="http://st.free.fr/phpmyvisites.js" type="text/javascript"></script>
<object><noscript><p>phpMyVisites | Open source web analytics
<img src="http://st.free.fr/phpmyvisites.php" alt="Statistics" style="border:0" />
</p></noscript></object></a>
<!-- /phpmyvisites --> 
</body>
</html>
