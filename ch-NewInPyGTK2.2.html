<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
<title>Chapitre 15. Nouveaux Widgets dans PyGTK 2.2</title>
<link rel="stylesheet" href="pygtktutfr.css">
<meta name="generator" content="Bluefish 1.0.5">
<meta name="keywords" content="python,pygtk,tutoriel,traduction,clipboard" />
<link rel="start" href="index.html" title="Tutoriel PyGTK 2.0">
<link rel="up" href="index.html" title="Tutoriel PyGTK 2.0">
<link rel="prev" href="sec-GenericCellRenderer.html" title="14.12. The Generic CellRenderer">
<link rel="next" href="ch-NewInPyGTK2.4.html" title="Chapitre 16. Nouveaux Widgets dans PyGTK 2.4">
</head>
<body>
<div class="localisation">
Vous êtes à peu près ici :
<a href="../../index.html">Accueil</a>&nbsp;  &raquo;  &nbsp;
<a href="../pygtktut.php">tutoriel PyGTK</a>&nbsp; &raquo; &nbsp;
 <a href="index.html">PyGTK : sommaire</a>
</div> <!-- fin localisation -->
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Chapitre 15. Nouveaux Widgets dans PyGTK 2.2</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="sec-GenericCellRenderer.html">Préc.</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="ch-NewInPyGTK2.4.html">Suiv.</a>
</tr>
</table>
<hr>
</div>
<div class="chapter" lang="fr">
<div class="titlepage"><div><div><h2 class="title">
<a name="ch-NewInPyGTK2.2"></a>Chapitre 15. Nouveaux Widgets dans PyGTK 2.2</h2>
</div></div></div>
<div class="toc">
<p><b>Table des matières</b></p>
<dl>
<dt><span class="sect1"><a href="ch-NewInPyGTK2.2.html#sec-Clipboards">15.1. Les Clipboards</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="ch-NewInPyGTK2.2.html#sec-CreatingClipboard">15.1.1. Créer un clipboard</a></span></dt>
<dt><span class="sect2"><a href="ch-NewInPyGTK2.2.html#sec-UsingClipboards">15.1.2. Utiliser les Clipboard avec les Entry, Spinbutton et TextView</a></span></dt>
<dt><span class="sect2"><a href="ch-NewInPyGTK2.2.html#sec-SettingClipboardData">15.1.3. Affecter des données à un Clipboard</a></span></dt>
<dt><span class="sect2"><a href="ch-NewInPyGTK2.2.html#sec-RetrievingClipboardContents">15.1.4. Récupérer le contenu du Clipboard</a></span></dt>
<dt><span class="sect2"><a href="ch-NewInPyGTK2.2.html#sec-ClipboardExample">15.1.5. Exemple de Clipboard</a></span></dt>
</dl></dd>
</dl>
</div>
<p>L'objet <code class="classname">Clipboard</code> a été ajouté en PyGTK 2.2. Le
<code class="classname">GtkClipboard</code> était disponible en GTK+ 2.0 mais
n'était pas utilisé par PyGTK 2.0 car il n'était pas un
<code class="classname">GObject</code> complet. Quelques nouveaux objets ont été ajoutés
au module gtk.gdk de PyGTK 2.2 mais ils ne seront pas décrits dans ce tutoriel.
Lisez le <a href="http://www.pygtk.org/pygtk2reference/index.html" target="_top">PyGTK 2
Reference Manual</a> pour obtenir des informations sur les objets
<code class="classname">gtk.gdk.Display</code>,
<code class="classname">gtk.gdk.DisplayManager</code> et
<code class="classname">gtk.gdk.Screen</code>
</p>
<div class="sect1" lang="fr">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="sec-Clipboards"></a>15.1. Les Clipboards</h2></div></div></div>
<p>Un <code class="classname">Clipboard</code> fournit une zone de stockage pour partager
des données entre processus ou entre différents widgets du même
processus. Chaque <code class="classname">Clipboard</code> est identifié par un nom
encodé en tant que <code class="classname">gdk.Atom</code>. On peut utiliser n'importe
quel nom souhaité pour identifier un <code class="classname">Clipboard</code>, celui-ci
sera créé s'il n'existe pas. Si on souhaite partager un <code class="classname">Clipboard</code>
avec d'autres processus, chaque processus doit connaître le nom du
<code class="classname">Clipboard</code>.
</p>
<p>Les <code class="classname">Clipboard</code> sont construits à partir des
<code class="classname">SelectionData</code> et des interfaces de sélection. Le
<code class="classname">Clipboard</code> par défaut utilisé par les widgets
<code class="classname">TextView</code>, <code class="classname">Label</code> et
<code class="classname">Entry</code> se nomme "CLIPBOARD". Les autres clipboards
courants sont  "PRIMARY" et "SECONDARY", ce qui correspond aux sélections
primaires et secondaires (inconnues de Win32). Elles peuvent aussi être
désignées par les objets <code class="classname">gtk.gdk.Atom</code> :
<code class="literal">gtk.gdk.SELECTION_CLIPBOARD</code>,
<code class="literal">gtk.gdk.SELECTION_PRIMARY</code> et
<code class="literal">gtk.gdk.SELECTION_SECONDARY</code>.  Se reporter à la
<a href="http://www.pygtk.org/pygtk2reference/class-gdkatom.html" target="_top">
 documentation de référence gtk.gdk.Atom</a> pour plus d'information.
</p>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-CreatingClipboard"></a>15.1.1. Créer un clipboard</h3></div></div></div>
<p>Un <code class="classname">Clipboard</code> est créé par le
constructeur :</p>
<pre class="programlisting">
  presse_papier = gtk.Clipboard(<strong class="parameter"><code>display</code></strong>, <strong class="parameter"><code>selection</code></strong>)
</pre>
<p>...où <em class="parameter"><code>display</code></em> est le <code class="classname">gtk.gdk.Display</code>
associé avec le <code class="classname">Clipboard</code> désigné par le paramètre
<em class="parameter"><code>selection</code></em>.
La fonction suivante crée un <code class="classname">Clipboard</code> en utilisant le
<code class="classname">gtk.gdk.Display</code> par défaut :

</p>
<pre class="programlisting">
  presse_papier = gtk.clipboard_get(<strong class="parameter"><code>selection</code></strong>)
</pre>
<p>Enfin, un <code class="classname">Clipboard</code> peut aussi être créé par la
méthode <code class="classname">Widget</code> :
</p>
<pre class="programlisting">
  presse_papier = widget.get_clipboard(<strong class="parameter"><code>selection</code></strong>)
</pre>
<p>Le widget doit être "réalisé" et appartenir à la hiérarchie de la fenêtre
racine.
</p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-UsingClipboards"></a>15.1.2. Utiliser les Clipboard avec les Entry, Spinbutton et TextView</h3></div></div></div>
<p>Les widgets <code class="classname">Entry</code>, <code class="classname">SpinButton</code>
et <code class="classname">TextView</code> possèdent des menus contextuels qui offrent la
possibilité de couper ou copier le texte sélectionné et de le coller à partir
du presse-papier "CLIPBOARD". De plus, des liens sont établis
 pour permettre des raccourcis clavier pour couper, copier et coller.
Couper est activé par <span><strong class="keycap">Control</strong></span>+<span><strong class="keycap">X</strong></span> ,
copier par <span><strong class="keycap">Control</strong></span>+<span><strong class="keycap">C</strong></span> et
coller par <span><strong class="keycap">Control</strong></span>+<span><strong class="keycap">V</strong></span>.
</p>
<p>Les widgets (<code class="classname">Entry</code> et
<code class="classname">SpinButton</code>) mettent en oeuvre l'interface
<code class="classname">Editable</code> qui possède les méthodes suivantes pour
couper, copier et coller de et vers le "CLIPBOARD" clipboard :
</p>
<pre class="programlisting">
  editable.cut_clipboard()
  editable.copy_clipboard()
  editable.paste_clipboard()
</pre>
<p>Un <code class="classname">Label</code> sélectionnable (la propriété "selectable"
vaut <code class="literal">TRUE</code>) permet aussi de copier le texte dans le
presse-papier "CLIPBOARD"
</p>en utilisant un menu contextuel ou  le raccourci clavier
<span><strong class="keycap">Control</strong></span>+<span><strong class="keycap">C</strong></span>.

        <p>Les <code class="classname">TextBuffer</code> ont des méthodes similaires bien qu'ils
permettent aussi de préciser le presse-papier à utiliser :
</p>
<pre class="programlisting">
  textbuffer.copy_clipboard(<strong class="parameter"><code>clipboard</code></strong>)
</pre>
<p>Le texte sélectionné sera copié dans le <code class="classname">Clipboard</code>
indiqué par <em class="parameter"><code>clipboard</code></em>.
</p>
<pre class="programlisting">
  textbuffer.cut_clipboard(<strong class="parameter"><code>clipboard</code></strong>, <strong class="parameter"><code>default_editable</code></strong>)
</pre>
<p>Le texte sélectionné sera copié dans <em class="parameter"><code>clipboard</code></em>.
Si le paramètre <em class="parameter"><code>default_editable</code></em> vaut
<code class="literal">TRUE</code>, le texte sélectionné sera aussi effacé du
<code class="classname">TextBuffer</code>. Sinon, la methode
<code class="methodname">cut_clipboard</code>() fonctionnera comme la méthode
<code class="methodname">copy_clipboard</code>() .
</p>
<pre class="programlisting">
  textbuffer.paste_clipboard(<strong class="parameter"><code>clipboard</code></strong>, <strong class="parameter"><code>override_location</code></strong>, <strong class="parameter"><code>default_editable</code></strong>)
</pre>
<p>Si le paramètre <em class="parameter"><code>default_editable</code></em> vaut
<code class="literal">TRUE</code>,
le contenu de <em class="parameter"><code>clipboard</code></em> sera inséré dans le
<code class="classname">TextBuffer</code> à l'endroit indiqué par le paramètre
<em class="parameter"><code>override_location</code></em> du <code class="classname">TextIter</code>
</p>. Si <em class="parameter"><code>default_editable</code></em> vaut <code class="literal">FALSE</code>,
la méthode <code class="methodname">paste_clipboard</code>() n'insèrera pas le
contenu de <em class="parameter"><code>clipboard</code></em>. Si le paramètre
<em class="parameter"><code>override_location</code></em> vaut <code class="literal">None</code>, le contenu de
<em class="parameter"><code>clipboard</code></em> sera inséré à l'emplacement du curseur.

        <p>Les <code class="classname">TextBuffer</code> possèdent aussi deux méthodes
pour gérer un ensemble de <code class="classname">Clipboard</code> qui sont automatiquement
affectés avec le contenu de la sélection en cours :
</p>
<pre class="programlisting">
  textbuffer.add_selection_clipboard(<strong class="parameter"><code>clipboard</code></strong>)
  textbuffer.remove_selection_clipboard(<strong class="parameter"><code>clipboard</code></strong>)
</pre>
<p>Quand un <code class="classname">TextBuffer</code> est ajouté à un
<code class="classname">TextView</code>, le presse-papiers "PRIMARY" est automatiquement
ajouté aux presse-papiers choisis. L'application peut ajouter d'autres presse-papiers,
(par exemple le presse-papier "CLIPBOARD").
</p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-SettingClipboardData"></a>15.1.3. Affecter des données à un Clipboard</h3></div></div></div>
<p>Il est possible d'affecter des données au <code class="classname">Clipboard</code>
par programme  en utilisant l'une de ces méthodes :
</p>
<pre class="programlisting">
  presse_papier.set_with_data(<strong class="parameter"><code>cibles</code></strong>, <strong class="parameter"><code>get_func</code></strong>, <strong class="parameter"><code>clear_func</code></strong>, <strong class="parameter"><code>donnees_utilisateur</code></strong>)

  presse_papier.set_text(<strong class="parameter"><code>text</code></strong>, <strong class="parameter"><code>len</code></strong>=-1)
</pre>
<p>La méthode <code class="methodname">set_with_data</code>() indique quelles cibles de
données sélectionnées sont acceptées et fournit les fonctions
(<em class="parameter"><code>get_func</code></em> et <em class="parameter"><code>clear_func</code></em>) qui
sont appelées quand les données sont appelées ou quand les données du presse-papiers
sont  modifiées. Le paramètre <em class="parameter"><code>donnees_utilisateur</code></em> est transmis
à  <em class="parameter"><code>get_func</code></em> où  à <em class="parameter"><code>clear_func</code></em>
quand elles sont appelées. Le paramètre <em class="parameter"><code>cibles</code></em> est une
liste de 3-tuples contenant :
</p>
<div class="itemizedlist"><ul type="disc">
<li>une chaîne représentant une cible acceptée
            par le presse-papiers.</li>
<li>une valeur de drapeau utilisée pour le glisser/déposer -
            on utilise 0.</li>
<li>un entier affecté à l'application qui est transmis comme paramètre
            au gestionnaire de signal pour aider à identifier le type de cible.</li>
</ul></div>
<p>Les paramètres de <em class="parameter"><code>get_func</code></em> et de
<em class="parameter"><code>clear_func</code></em> sont :
</p>
<pre class="programlisting">
  def get_func(presse_papier, donnees_selection, info, data):

  def clear_func(presse_papier, data):
</pre>
<p>...où le paramètre <em class="parameter"><code>presse_papier</code></em> est le
        <code class="classname">Clipboard</code>, le paramètre <em class="parameter"><code>donnees_selection</code></em>
        est un objet  <code class="classname">SelectionData</code> contenant les données, le paramètre
<em class="parameter"><code>info</code></em>  est l'entier assigné à l'application, associé à une cible
et le paramètre <em class="parameter"><code>data</code></em> représente les données utilisateur.
</p>
<p>La méthode <code class="methodname">set_text</code>() est une méthode commode
qui utilise la méthode <code class="methodname">set_with_data</code>() pour
placer les données texte dans un <code class="classname">Clipboard</code> avec pour
cibles : "STRING", "TEXT", "COMPOUND_TEXT", et "UTF8_STRING". Elle utilise
les fonctions internes get et clear pour gérer les données. Cette méthode
est équivalente à :
</p>
<pre class="programlisting">
  def my_set_text(self, texte, len=-1):
      targets = [ ("STRING", 0, 0),
                  ("TEXT", 0, 1),
                  ("COMPOUND_TEXT", 0, 2),
                  ("UTF8_STRING", 0, 3) ]
      def text_get_func(presse_papier, donnees_selection, info, data):
          selection.set_text(data)
          return
      def text_clear_func(presse_papier, data):
          del data
          return
      self.set_with_data(cibles, text_get_func, text_clear_func, texte)
      return
</pre>
<p>Une fois les données placées dans le presse-papiers, elles demeurent disponibles
jusqu'à la fermeture de l'application ou jusqu'à leur remplacement.
</p>
<p>Pour obtenir le comportement habituel du couper dans un presse-papiers,
l'application doit supprimer le texte ou l'objet sélectionné après
l'avoir recopié dans le presse-papiers.
</p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-RetrievingClipboardContents"></a>15.1.4. Récupérer le contenu du Clipboard</h3></div></div></div>
<p>Le contenu du <code class="classname">Clipboard</code> peut être récupéré
avec la méthode suivante :
</p>
<pre class="programlisting">
  clipboard.request_contents(<strong class="parameter"><code>target</code></strong>, <strong class="parameter"><code>callback</code></strong>, <strong class="parameter"><code>user_data</code></strong>=None)
</pre>
<p>Les contenus indiqués par <em class="parameter"><code>target</code></em> sont récupérés de
manière asynchrone dans la fonction indiquée par le paramètre
<em class="parameter"><code>callback</code></em> qui est appelé avec <em class="parameter"><code>user_data</code></em>.
le paramètre <em class="parameter"><code>callback</code></em> a la forme :
</p>
<pre class="programlisting">
  def callback(presse_papier, donnees_selection, data):
</pre>
<p>... où <em class="parameter"><code>donnees_selection</code></em> est un objet <code class="classname">SelectionData</code>
conservant le contenu du <em class="parameter"><code>presse_papier</code></em>. <em class="parameter"><code>data</code></em>
contient les <em class="parameter"><code>données utilisateur</code></em>. La méthode <code class="methodname">request_contents</code>()
est la façon la plus commune de récupérer le contenu d'un <code class="classname">Clipboard</code>.
La méthode suivante est commode pour retrouver le contenu texte d'un <code class="classname">Clipboard</code> :

</p>
<pre class="programlisting">
  clipboard.request_text(<strong class="parameter"><code>callback</code></strong>, <strong class="parameter"><code>user_data</code></strong>=None)
</pre>
<p>La chaîne texte est renvoyée à la fonction de rappel à la place d'un objet
<code class="classname">Selectiondata</code>. Vous pouvez vérifier quelles cibles sont
disponibles sur le  <code class="classname">Clipboard</code> en employant la méthode :
</p>
<pre class="programlisting">
  clipboard.request_targets(<strong class="parameter"><code>callback</code></strong>, <strong class="parameter"><code>user_data</code></strong>=None)
</pre>
<p>Les cibles sont retournées à la fonction de rappel comme un tuple d'objets
<code class="classname">gtk.gdk.Atom</code>.
</p>
<p>Deux méthodes pratiques sont fournies pour renvoyer le contenu du
<code class="classname">Clipboard</code> de manière synchrone :
</p>
<pre class="programlisting">
  donnees_selection = clipboard.wait_for_contents(cible)

  texte = clipboard.wait_for_text()
</pre>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-ClipboardExample"></a>15.1.5. Exemple de Clipboard</h3></div></div></div>
<p>Pour illustrer l'utilisation d'un <code class="classname">Clipboard</code>, le programme
<a href="exemples/clipboard.py" target="_top">clipboard.py</a> récupère les éléments de texte
qui sont coupés ou copiés vers le presse-papiers "CLIPBOARD" et sauvegarde les dix
dernières entrées du presse-papiers. Il y a dix boutons qui permettent d'accéder
au texte des entrées sauvegardées. Le texte du bouton affiche les seize premiers
caractères du texte sauvé et les infobulles montrent les cibles que la zone de texte avait à l'origine.
Quand on clique sur un bouton d'entrée, le texte sauvegardé associé s'inscrit
dans la fenêtre de texte ; il est modifiable. Le bouton sous la fenêtre de texte sauvegarde
le contenu actuel de la fenêtre dans le presse-papiers.
</p>
<p><a href="ch-NewInPyGTK2.2.html#clipboardfig" title="Figure 15.1. Exemple de Clipboard">Figure 15.1, « Exemple de Clipboard »</a> montre le programme <a href="exemples/clipboard.py" target="_top">clipboard.py</a> en action :</p>
<div class="figure">
<a name="clipboardfig"></a><p class="title"><b>Figure 15.1. Exemple de Clipboard</b></p>
<div class="mediaobject" align="center"><img src="figures/clipboard.png" align="middle" alt="Programme d'exemple de Clipboard"></div>
</div>
<p>Le programme d'exemple sonde le presse-papiers toutes les 1,5 secondes pour voir
si le contenu a changé. Le programme peut être modifié pour dupliquer la totalité
de contenu de cible et prendre le contrôle en employant la méthode
<code class="methodname">set_with_data</code>(). Plus tard, quand un autre programme
place du contenu dans le presse-papiers, le paramètre <em class="parameter"><code>clear_func</code></em> sera
appelé , il pourra être utilisé pour recharger le contenu du presse-papiers et en
reprendre le contrôle .
</p>
</div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="sec-GenericCellRenderer.html">Préc.</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="ch-NewInPyGTK2.4.html">Suiv.</a>
</tr>
<tr>
<td width="40%" align="left" valign="top">14.12. The Generic CellRenderer </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Table des matières</a></td>
<td width="40%" align="right" valign="top"> Chapitre 16. Nouveaux Widgets dans PyGTK 2.4</td>
</tr>
</table>
</div>
</body>
</html>
