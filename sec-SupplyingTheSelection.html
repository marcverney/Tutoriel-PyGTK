<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>21.3. Alimenter la sélection</title>
<link rel="stylesheet" href="pygtktutfr.css" type="text/css">
<meta name="generator" content="Bluefish 1.0.5">
<link rel="start" href="index.html" title="Tutoriel PyGTK 2.0">
<link rel="up" href="ch-ManagingSelections.html" title="Chapitre 21. Gérer les sélections">
<link rel="prev" href="sec-RetrievingTheSelection.html" title="21.2. Récupérer la sélection">
<link rel="next" href="ch-DragAndDrop.html" title="Chapitre 22. Le glisser-déposer (DND)">
<meta name="keywords" content="python,pygtk,tutoriel,traduction">
<link rel="home" href="index.html" title="Table des matières">
</head>
<body>
<div class="localisation"> 
 Vous êtes à peu près ici :  
 <a href="../../index.html">Accueil</a>&nbsp; &raquo; &nbsp;
 <a href="../pygtktut.php">tutoriel PyGTK</a>&nbsp; &raquo; &nbsp;
 <a href="index.html">PyGTK : sommaire</a>
</div>
<!-- fin localisation -->
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">21.3. Alimenter la sélection</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="sec-RetrievingTheSelection.html">Préc.</a> </td>
<th width="60%" align="center">Chapitre 21. Gérer les sélections</th>
<td width="20%" align="right"> <a accesskey="n" href="ch-DragAndDrop.html">Suiv.</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1" lang="fr">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="sec-SupplyingTheSelection"></a>21.3. Alimenter la sélection</h2></div></div></div>
<p>Alimenter la sélection est un peu plus compliqué. Il faut enregistrer 
des gestionnaires que l'on appelera lorsque la sélection sera réclamée. 
Pour chaque paire de sélection/cible à gérer, on fait un appel à :
</p>
<pre class="programlisting">
  widget.selection_add_target(<strong class="parameter"><code>selection</code></strong>, <strong class="parameter"><code>target</code></strong>, <strong class="parameter"><code>info</code></strong>)
</pre>
<p>... où les paramètres <em class="parameter"><code>widget</code></em>, 
<em class="parameter"><code>selection</code></em> et <em class="parameter"><code>target</code></em> 
identifient les requêtes dont doit s'occuper ce gestionnaire. Quand une 
demande pour une sélection est reçue, on appellera le signal "selection_get". 
Le paramètre <em class="parameter"><code>info</code></em> est un nombre entier qui peut être 
utilisé comme un identifiant pour la cible spécifique dans le rappel.
</p>
<p>La fonction de rappel a la forme :</p>
<pre class="programlisting">
  def selection_get(widget, selection_data, info, time):
</pre>
<p>Le <code class="classname">gtk.SelectionData</code> est le même que précédemment, 
mais cette fois-ci, on est chargé de remplir les champs <em class="parameter"><code>type</code></em>, 
<em class="parameter"><code>format</code></em> et <em class="parameter"><code>data</code></em>. Le paramètre 
<em class="parameter"><code>format</code></em> est important ici - le serveur X l'utilise 
pour savoir si <em class="parameter"><code>data</code></em> nécessite un changement de 
l'ordre de ses bytes ou non. Habituellement la valeur est 8, c'est à dire 
un caractère, ou 32 pour un entier). Ceci est réalisé en appelant la 
méthode :
</p>
<pre class="programlisting">
  selection_data.set(<strong class="parameter"><code>type</code></strong>, <strong class="parameter"><code>format</code></strong>, <strong class="parameter"><code>data</code></strong>)
</pre>
<p>Cette méthode PyGTK peut seulement manipuler des chaînes de caractères 
donc le paramètre <em class="parameter"><code>data</code></em> doit être inclus dans une chaîne 
Python, mais le <em class="parameter"><code>format</code></em> sera de la dimension
appropriée (par ex. 32 pour les atomes et les nombres entiers, 8 pour les 
chaînes). Les  modules Python <code class="classname">struct</code> ou <code class="classname">StringIO</code> 
peuvent être utilisés pour convertir des données non-chaîne en chaîne de caractères. 
Par exemple, vous pouvez convertir une liste de nombres entiers vers une chaîne 
et renseigner le <em class="parameter"><code>selection_data</code></em> par :</p>
<pre class="programlisting">
  ilist = [1, 2, 3, 4, 5]

  data = apply(struct.pack, ['%di'%len(ilist)] + ilist)

  selection_data.set("INTEGER", 32, data)
</pre>
<p>La méthode suivante établit les données de la sélection à partir 
de la chaîne indiquée :
</p>
<pre class="programlisting">
  selection_data.set_text(<strong class="parameter"><code>str</code></strong>, <strong class="parameter"><code>len</code></strong>)
</pre>
<p>À la demande de l'utilisateur, on réclame la propriété de la 
sélection en appelant :
</p>
<pre class="programlisting">
  result = widget.selection_owner_set(<strong class="parameter"><code>selection</code></strong>, <strong class="parameter"><code>time</code></strong>=0L)
</pre>
<p>... où  <em class="parameter"><code>result</code></em> vaut <code class="literal">TRUE</code> 
si le programme a réclamé la sélection <em class="parameter"><code>selection</code></em> 
avec succès. Si une autre application réclame la possession 
de la sélection, on obtiendra une réponse "selection_clear_event". 
</p>
<p>Comme exemple de fourniture de sélection, le programme 
<a href="exemples/setselection.py" target="_top"><span><strong class="command">setselection.py</strong></span></a> 
ajoute une fonction de sélection à un bouton interrupteur compris dans 
une boîte <code class="classname">gtk.EventBox</code>. Le 
<code class="classname">gtk.Eventbox</code> est nécessaire car la sélection doit 
être associée à une <code class="classname">gtk.gdk.Window</code> alors que le 
<code class="classname">gtk.Button</code> est un widget "sans fenêtre" dans GTK+ 2.0. 
Quand le bouton interrupteur est enfoncé, le programme réclame la propriété 
de la sélection primaire. La seule cible reconnue (à part certaines cibles 
comme  "TARGETS" fournies par GTK+ lui-même) est la cible "STRING". Lorsque 
cette cible est demandée, une représentation en chaîne de caractères du temps 
actuel est renvoyée. La <a href="sec-SupplyingTheSelection.html#setselectionfig" title="Figure 21.2. Exemple de création de sélection">Figure 21.2, « Exemple de création de sélection »</a> montre le programme 
au moment où il prend possession de la sélection primaire.
</p>
<div class="figure">
<a name="setselectionfig"></a><p class="title"><b>Figure 21.2. Exemple de création de sélection</b></p>
<div class="mediaobject" align="center"><img src="figures/setselection.png" align="middle" alt="Exemple de création de sélection"></div>
</div>
<p>Voici le code du programme <a href="exemples/setselection.py" target="_top">
    <span><strong class="command">setselection.py</strong></span></a> :</p>
<pre class="programlisting">
     1   #!/usr/bin/env python
     2   # -*- coding:utf-8 -*-
     3   # exemple setselection.py
     4   
     5   import pygtk
     6   pygtk.require('2.0')
     7   import gtk
     8   import time
     9   
    10   class SetSelectionExample:
    11       # Fonction de rappel quand l'utilisateur modifie la sélection.
    12       def selection_toggled(self, widget, window):
    13           if widget.get_active():
    14               self.have_selection = window.selection_owner_set("PRIMARY")
    15               # si réclamer la sélection échoue, on remet le bouton
    16               # dans l'état inactif.
    17               if not self.have_selection:
    18                   widget.set_active(False)
    19           else:
    20               if self.have_selection:
    21                   # Impossible de libérer la sélection en PyGTK,
    22                   # on indique juste que l'on ne la possède pas.
    23                   self.have_selection = False
    24           return
    25   
    26       # Appelé lorsqu'une autre application réclame la sélection.
    27       def selection_clear(self, widget, event):
    28           self.have_selection = False
    29           widget.set_active(False)
    30           return True
    31   
    32       # Fournit le temps actuel comme sélection.
    33       def selection_handle(self, widget, selection_data, info, time_stamp):
    34           current_time = time.time()
    35           timestr = time.asctime(time.localtime(current_time))
    36   
    37           # Quand on renvoie une chaîne unique, elle ne doit se terminer 
    38           # par une valeur nulle. Ceci le fait pour nous.
    39           selection_data.set_text(timestr, len(timestr))
    40           return
    41   
    42       def __init__(self):
    43           self.have_selection = False
    44           # Création de la fenêtre de niveau supérieur
    45           window = gtk.Window(gtk.WINDOW_TOPLEVEL)
    46           window.set_title("Set Selection")
    47           window.set_border_width(10)
    48           window.connect("destroy", lambda w: gtk.main_quit())
    49           self.window = window
    50           # Création d'une boîte évènement pour contenir le bouton 
    51           # car il n'a pas sa propre GdkWindow.
    52           eventbox = gtk.EventBox()
    53           eventbox.show()
    54           window.add(eventbox)
    55           
    56           # Création d'un bouton interrupteur pour agir avec la sélection
    57           selection_button = gtk.ToggleButton("Réclamer sélection")
    58           eventbox.add(selection_button)
    59   
    60           selection_button.connect("toggled", self.selection_toggled, eventbox)
    61           eventbox.connect_object("selection_clear_event", self.selection_clear,
    62                                   selection_button)
    63   
    64           eventbox.selection_add_target("PRIMARY", "STRING", 1)
    65           eventbox.selection_add_target("PRIMARY", "COMPOUND_TEXT", 1)
    66           eventbox.connect("selection_get", self.selection_handle)
    67           selection_button.show()
    68           window.show()
    69   
    70   def main():
    71       gtk.main()
    72       return 0
    73   
    74   if __name__ == "__main__":
    75       SetSelectionExample()
    76       main()
</pre>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="sec-RetrievingTheSelection.html">Préc.</a> </td>
<td width="20%" align="center"><a accesskey="u" href="ch-ManagingSelections.html">Chapitre parent</a></td>
<td width="40%" align="right"> <a accesskey="n" href="ch-DragAndDrop.html">Suiv.</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">21.2. Récupérer la sélection </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Table des matières</a></td>
<td width="40%" align="right" valign="top"> Chapitre 22. Le glisser-déposer (DND)</td>
</tr>
</table>
</div>
</body>
</html>
