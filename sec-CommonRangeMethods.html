<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
<title>8.3. Méthodes communes aux widgets d'intervalle</title>
<link rel="stylesheet" href="pygtktutfr.css">
<meta name="keywords" content="python,pygtk,tutoriel,traduction,intervalle">
<link rel="start" href="index.html" title="Tutoriel PyGTK 2.0">
<link rel="home" href="index.html" title="Table des matières">
<link rel="up" href="ch-RangeWidgets.html" title="Chapitre 8. Les widgets d'intervalle">
<link rel="previous" href="sec-ScaleWidgets.html" title="8.2. HScale et VScale : les gradateurs">
<link rel="next" href="sec-KeyAndMouseBindings.html" title="8.4. Clavier et souris">
</head>

<body>
<div class="navheader">
<table width="100%" summary="En-tête de navigation">
<tr>
<th colspan="3" align="center">8.3. Méthodes communes aux widgets d'intervalle</th>
</tr><tr>
<td width="20%" align="left"><a accesskey="p" href="sec-ScaleWidgets.html">Préc.</a></td>
<th width="60%" align="center">Chapitre 8. Les widgets d'intervalle</th>
<td width="20%" align="right"><a accesskey="n" href="sec-KeyAndMouseBindings.html">Suiv.</a></td>
</tr></table>

<hr>
</div>

<div class="sect1"><div class="titlepage"><div>
<h2 class="title" style="clear: both"><a name="MethodesCommunes"></a>8.3. Méthodes communes aux widgets d'intervalle</h2>
</div></div>

<p>La classe des widgets d'intervalle (<tt>gtk.Range</tt>) a des mécanismes internes assez compliqués, qui, comme tous ceux des classes "de base", ne sont pas très intéressants à moins de vouloir les bidouiller. De plus, parmi ses méthodes et signaux, la quasi totalité n'est vraiment utile que pour écrire des widgets dérivés. On trouve cependant quelques méthodes utiles qui fonctionnent avec tous les widgets de la classe.</p>

<div class="sect2"><div class="titlepage"><div>
<h3 class="title"><a name="id3060169"></a>8.3.1. Définir le mode d'actualisation</h3>
</div></div>

<p>Le "mode d'actualisation" d'un widget d'intervalle précise le moment où, durant sa manipulation par l'utilisateur, le widget devra changer la valeur de son <a href="ch-Adjustments.html" title="Chapitre 7. Les ch-Adjustments.html"><tt>ajustement</tt></a> et lui faire émettre le signal "<tt>value_changed</tt>". Les différents modes d'actualisation sont :</p>

<table border="0" width="100%" bgcolor="#FFECCE"><col align="left" valign="top" width="0*">
<tr>
<td><span class="term"> UPDATE_CONTINUOUS<br>(continu)</span></td>
<td><p>C'est le mode par défaut. Le signal "<tt>value_changed</tt>" est émis de manière continue, c'est-à-dire au moindre déplacement du curseur.</p></td>
</tr><tr>
<td><span class="term">UPDATE_DISCONTINUOUS<br>(discontinu)</span></td>
<td><p>Le signal "<tt>value_changed</tt>" n'est émis qu'après que le curseur a cessé de bouger et que l'utilisateur a relâché le bouton de la souris.</p></td>
</tr><tr>
<td><span class="term">UPDATE_DELAYED<br>(différé)</span></td>
<td><p>Le signal "<tt>value_changed</tt>" est émis lorsque l'utilisateur relâche le bouton de la souris, ou si le curseur cesse de bouger durant un court instant.</p>
</td></tr>
</table>

<p>On définit le mode d'actualisation d'un widget d'intervalle en l'indiquant à l'argument <i>policy</i> (mode) de cette méthode :</p>

<pre class="programlisting">
  widget.set_update_policy(<b><tt>policy</tt></b>)
</pre>

</div><div class="sect2"><div class="titlepage"><div>
<h3 class="title"><a name="id3060239"></a>8.3.2. Définir et récupérer les ajustements</h3>
</div></div>

<p>Pour définir et récupérer "à la volée" l'ajustement d'un widget d'intervalle, on utilise naturellement les méthodes :</p>

<pre class="programlisting">
  widget.set_adjustment(<b><tt>adjustment</tt></b>)

  ajustement = widget.get_adjustment()
</pre>

<p>La méthode <tt>get_adjustment</tt>() renvoie une référence à l'ajustement auquel <i><tt>widget</tt></i> est connecté.</p>
<p>La méthode <tt>set_adjustment</tt>() ne fait absolument rien si vous lui transmettez l'ajustement que <i><tt>widget</tt></i> utilise déjà, que vous ayez modifié ou non ses valeurs. En revanche, si vous lui passez un nouvel <a href="ch-Adjustments.html" title="Chapitre 7. Les ch-Adjustments.html"><tt>ajustement</tt></a>, elle déréférence le précédent s'il existe (voire le détruit), connecte les signaux appropriés au nouveau, puis recalcule la taille et/ou la position du curseur avant de le réafficher si nécessaire. Comme nous l'avons vu dans la section sur les <a href="ch-Adjustments.html" title="Chapitre 7. Les ch-Adjustments.html"><tt>ajustements</tt></a>, si vous voulez réutiliser le même, vous devriez lui faire émettre le signal "<tt>changed</tt>" quand vous modifiez directement ses valeurs :</p>

<pre class="programlisting">
  ajustement.emit("changed")
</pre>
</div></div>

<div class="navfooter">
<hr>

<table width="100%" summary="Bas de page de navigation">
<tr>
<td width="40%" align="left"><a accesskey="p" href="sec-ScaleWidgets.html">Préc.</a></td>
<td width="20%" align="center"><a accesskey="u" href="ch-RangeWidgets.html">Chapitre parent</a></td>
<td width="40%" align="right"><a accesskey="n" href="sec-KeyAndMouseBindings.html">Suiv.</a></td>
</tr><tr>
<td width="40%" align="left" valign="top">8.2. HScale et VScale : les gradateurs</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Table des matières</a></td>
<td width="40%" align="right" valign="top"> 8.4. Clavier et souris</td>
</tr></table>
</div>

</body>

</html>
